<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="时间就是一个小偷,它让你猝不及防地失去,那些你很容易忽略掉的东西,当你记起时，却怎么也找不着了...">
<meta property="og:type" content="website">
<meta property="og:title" content="HuJian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HuJian&#39;s Blog">
<meta property="og:description" content="时间就是一个小偷,它让你猝不及防地失去,那些你很容易忽略掉的东西,当你记起时，却怎么也找不着了...">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HuJian&#39;s Blog">
<meta name="twitter:description" content="时间就是一个小偷,它让你猝不及防地失去,那些你很容易忽略掉的东西,当你记起时，却怎么也找不着了...">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HuJian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuJian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/mobx-react源码之inject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/mobx-react源码之inject/" itemprop="url">mobx-react源码之inject</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T00:59:52+08:00">
                2019-04-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/08/mobx-react源码之inject/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/04/08/mobx-react源码之inject/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mobx-react的inject方法做了什么？？？</p>
<h1 id="START"><a href="#START" class="headerlink" title="START"></a>START</h1><p>当使用mobx配合react时，对于store的注入，都是inject配合装饰器的方法来使用，Provider是高阶组件，inject函数等于高阶组件，看如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123; inject, observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line">@inject(<span class="string">'myStore'</span>) @observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.myStore)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                MyComp</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当Provider注入了mobxStore到组件之后，实际上mobxStore是挂载到this.context中的</span><br><span class="line">inject的作用就是把参数作为key值从mobxStore里取出，this.context.mobxStores[key]</span><br><span class="line">取出之后把组件和取出的值重新生成新的组件(高阶组件)</span><br><span class="line">inject先执行返回一个函数，装饰器再把组件作为参数传给这个返回的函数</span><br></pre></td></tr></table></figure>
<h1 id="inject源码"><a href="#inject源码" class="headerlink" title="inject源码"></a>inject源码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> grabStoresFn</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">"function"</span>) &#123; <span class="comment">// 如果参数为函数</span></span><br><span class="line">        grabStoresFn = <span class="built_in">arguments</span>[<span class="number">0</span>] <span class="comment">// 直接把参数作为获取store的函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">componentClass</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> injected = createStoreInjector(grabStoresFn, componentClass) <span class="comment">// 返回Injector组件</span></span><br><span class="line">            injected.isMobxInjector = <span class="literal">false</span></span><br><span class="line">            injected = observer(injected) <span class="comment">// 把新组件作一次observer</span></span><br><span class="line">            injected.isMobxInjector = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> injected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是函数，即是多个字符串的形式</span></span><br><span class="line">        <span class="keyword">const</span> storeNames = []</span><br><span class="line">        <span class="comment">// 循环字符串参数，放到storeNames数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) storeNames[i] = <span class="built_in">arguments</span>[i]</span><br><span class="line">        <span class="comment">// 调用grabStoresByName，返回了匿名函数function(baseStores, nextProps)</span></span><br><span class="line">        grabStoresFn = grabStoresByName(storeNames)</span><br><span class="line">        <span class="comment">// 同理，最后也是返回了Injector组件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">componentClass</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createStoreInjector(grabStoresFn, componentClass, storeNames.join(<span class="string">"-"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="inject方法解析"><a href="#inject方法解析" class="headerlink" title="inject方法解析"></a>inject方法解析</h1><p>1,inject通过arguments来获取参数，所以可以传入多个storeName<br>2,如果传入的fn，就把这个函数当作获取store的函数，接受mobxStore作为参数，返回对象{}<br>3,如果传入的是字符串，先调用一次grabStoresByName</p>
<h1 id="grabStoresByName方法解析"><a href="#grabStoresByName方法解析" class="headerlink" title="grabStoresByName方法解析"></a>grabStoresByName方法解析</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grabStoresByName</span>(<span class="params">storeNames</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">baseStores, nextProps</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// storeNames是数组，包含了需要的storeName，从context.mobxStores中取出对应值</span></span><br><span class="line">        storeNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">storeName</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// storeName不能在props中定义过的</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                storeName <span class="keyword">in</span> nextProps</span><br><span class="line">            )</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// storeName不能是不存在的属性</span></span><br><span class="line">            <span class="keyword">if</span> (!(storeName <span class="keyword">in</span> baseStores))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                    <span class="string">"MobX injector: Store '"</span> +</span><br><span class="line">                        storeName +</span><br><span class="line">                        <span class="string">"' is not available! Make sure it is provided by some Provider"</span></span><br><span class="line">                )</span><br><span class="line">            <span class="comment">// 添加需要的属性值</span></span><br><span class="line">            nextProps[storeName] = baseStores[storeName]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> nextProps</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1,grabStoresByName返回函数，这个函数将在inject()(grabStoresFn)作为参数<br>2,baseStores === context.mobxStores<br>3,如果storeName在props中存在，将会直接返回，不会放到props中，如果storeName不存在，会抛出错误提示</p>
<h1 id="createStoreInjector函数解析"><a href="#createStoreInjector函数解析" class="headerlink" title="createStoreInjector函数解析"></a>createStoreInjector函数解析</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStoreInjector</span>(<span class="params">grabStoresFn, component, injectNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 组件名</span></span><br><span class="line">    <span class="keyword">let</span> displayName =</span><br><span class="line">        <span class="string">"inject-"</span> +</span><br><span class="line">        (component.displayName ||</span><br><span class="line">            component.name ||</span><br><span class="line">            (component.constructor &amp;&amp; component.constructor.name) ||</span><br><span class="line">            <span class="string">"Unknown"</span>)</span><br><span class="line">    <span class="keyword">if</span> (injectNames) displayName += <span class="string">"-with-"</span> + injectNames</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Injector</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> displayName = displayName</span><br><span class="line"></span><br><span class="line">        storeRef = <span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.wrappedInstance = instance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">let</span> newProps = &#123;&#125;</span><br><span class="line">            <span class="comment">// 拿到Injector自身props</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.props)</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.props.hasOwnProperty(key)) &#123;</span><br><span class="line">                    newProps[key] = <span class="keyword">this</span>.props[key]</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 附加props：@inject(storeName), 获取到this.context.mobxStores[storeName]</span></span><br><span class="line">            <span class="keyword">var</span> additionalProps =</span><br><span class="line">                grabStoresFn(<span class="keyword">this</span>.context.mobxStores || &#123;&#125;, newProps, <span class="keyword">this</span>.context) || &#123;&#125;</span><br><span class="line">            <span class="comment">// 遍历添加新属性值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> additionalProps) &#123;</span><br><span class="line">                newProps[key] = additionalProps[key]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isStateless(component)) &#123;</span><br><span class="line">                newProps.ref = <span class="keyword">this</span>.storeRef</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成新的DOM：等于&lt;component ...newProps /&gt;  个人理解</span></span><br><span class="line">            <span class="keyword">return</span> createElement(component, newProps)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不作分析，未知其实际作用-- start</span></span><br><span class="line">    hoistStatics(Injector, component)</span><br><span class="line"></span><br><span class="line">    Injector.wrappedComponent = component</span><br><span class="line">    <span class="comment">// end</span></span><br><span class="line">    <span class="comment">// 重要！！！必须有proxiedInjectorProps，Injector才能从父组件拿到context.mobxStores</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Injector, proxiedInjectorProps)</span><br><span class="line">    <span class="keyword">return</span> Injector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1,displayName将作为组件名字存在<br>2,函数最后返回的是Injector组件<br>3,render返回值：首先把Injector自身props和需要的mobxStores数据全部遍历到newProps中，然后调用createElement生成DOM (createElement属于react源码方法，暂未阅读)<br>4,Injector组件的contextTypes是不允许更改的<br>5,isStateless判断是否是函数组件</p>
<h1 id="为什么Inject可以获取到mobxStores-看如下代码"><a href="#为什么Inject可以获取到mobxStores-看如下代码" class="headerlink" title="为什么Inject可以获取到mobxStores, 看如下代码"></a>为什么Inject可以获取到mobxStores, 看如下代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider &#123;...rootStore.store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById("root")</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App.js代码</span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 如果没有这个contextTypes，context将会是一个空对象</span></span><br><span class="line"><span class="regexp">    static contextTypes = &#123;</span></span><br><span class="line"><span class="regexp">        mobxStores: PropTypes.object</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">        console.log(this.context)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">                app.js</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1,Provider高阶组件定义了getChildContext方法：定义了子组件的context将会返回什么数据<br>2,子组件必须定义contextTypes去获取context中想要的数据，inject方法最终会返回Injector组件，Injector帮你做了这件事，所以在Injector中是可以拿到context的<br><img src="http://cdn.jsprogram.cn/1522138075.png?imageMogr2/thumbnail/!70p"><br>最终逻辑就是Provider定义了context返回数据，Injector拿到了mobxStores，与App组件生成一个带props的新组件</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>inject等于高阶组件，返回函数，函数的执行返回Injector组件，props的获取从this.context.mobxStores拿到</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/React-DOM操作的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/React-DOM操作的原理/" itemprop="url">React DOM操作的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T18:17:01+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/06/React-DOM操作的原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/06/React-DOM操作的原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h2 id="基础的DOM原理"><a href="#基础的DOM原理" class="headerlink" title="基础的DOM原理"></a>基础的DOM原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state 数据</span><br><span class="line">JSX 模板</span><br><span class="line">数据 + 模板 结合, 生成真实的DOM, 显示</span><br><span class="line">state 发生改变</span><br><span class="line">数据 + 模板 结合, 生成真实的DOM, 替换原始的DOM</span><br></pre></td></tr></table></figure>
<p>缺陷: DOM片段整个整个替换会很耗性能</p>
<h2 id="改进的DOM原理"><a href="#改进的DOM原理" class="headerlink" title="改进的DOM原理"></a>改进的DOM原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state 数据</span><br><span class="line">JSX模板</span><br><span class="line">数据 + 模板 结合, 生成真实的DOM, 显示</span><br><span class="line">state变化</span><br><span class="line">数据 + 模板结合, 生成新的真实的DOM, 并不直接替换原始的DOM</span><br><span class="line">新的DOM (DoucumentFragment文档碎片, 没那么耗性能) 和原始的DOM做对比, 找差异(DOM之间的比较)</span><br><span class="line">找到input 框的变化</span><br><span class="line">只用新的DOM中的input 元素进行替换老元素</span><br></pre></td></tr></table></figure>
<p>缺陷: 全部替换 –&gt; 生成新的DoucumentFragment, DOM之间比较(DOM比对也耗性能) –&gt; 只替换DOM</p>
<h2 id="React的DOM原理"><a href="#React的DOM原理" class="headerlink" title="React的DOM原理"></a>React的DOM原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">state 数据</span><br><span class="line">JSX模板</span><br><span class="line">数据 + 模板 生成虚拟DOM( 虚拟DOM 本质就是 JS对象 , 用来描述真实的DOM) (减少损耗)</span><br><span class="line">    [<span class="string">'div'</span>, &#123;id: <span class="string">'abc'</span>&#125;, [<span class="string">'span'</span>, &#123;&#125;, <span class="string">'Hello'</span>]]  --&gt; js对象[<span class="string">'标签名'</span>, &#123;属性对象&#125;, 子节点]的嵌套成虚拟DOM树</span><br><span class="line"></span><br><span class="line">用虚拟DOM, 生成真实的DOM, 显示</span><br><span class="line">    &lt;div id=<span class="string">"abc"</span>&gt;&lt;span&gt; Hello &lt;/span&gt;&lt;/div&gt; --&gt; 真实的DOM</span><br><span class="line"></span><br><span class="line">state发生变化</span><br><span class="line">数据 + 模板 生成新的虚拟DOM, 只是比较 js对象 的差异, 进行改变(极大的提示性能)</span><br><span class="line">    [<span class="string">'div'</span>, &#123;id: <span class="string">'abc'</span>&#125;, [<span class="string">'span'</span>, &#123;&#125;, <span class="string">'Bye'</span>]]</span><br><span class="line"></span><br><span class="line">比较虚拟DOM(也即JS对象) 的差别</span><br><span class="line">直接操作DOM, 改变span 中的内容</span><br></pre></td></tr></table></figure>
<p>改进: 整个DOM的替换 -&gt; 生成新的DOM(DocumentFragement), 比较DOM, 替换DOM -&gt; 生成虚拟DOM(JS对象), 比较虚拟DOM(比较js对象), 替换DOM</p>
<p>优点:<br>    1,性能提升<br>    2,虚拟DOM 使得跨端应用得以实现, React Native, 虚拟DOM本身是js对象(web, 原生应用都可以识别), 网页里面渲染成DOM, 原生里面渲染成原生组件</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/node-异步和同步处理过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/node-异步和同步处理过程/" itemprop="url">node 异步和同步处理过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T11:35:55+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/25/node-异步和同步处理过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/25/node-异步和同步处理过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/node-puppeteer模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/node-puppeteer模块/" itemprop="url">node puppeteer模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T16:57:06+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/node-puppeteer模块/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/node-puppeteer模块/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于puppeteer"><a href="#关于puppeteer" class="headerlink" title="关于puppeteer"></a>关于puppeteer</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppeteer是一个node库，他提供了一组用来操纵Chrome的API（默认headless也就是无UI的chrome，也可以配置为有UI）</span><br><span class="line"></span><br><span class="line">有点类似于PhantomJS，但Puppeteer是Chrome官方团队进行维护的，前景更好。</span><br></pre></td></tr></table></figure>
<h2 id="puppeteer可以做什么"><a href="#puppeteer可以做什么" class="headerlink" title="puppeteer可以做什么?"></a>puppeteer可以做什么?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用网页生成PDF、图片</span><br><span class="line">爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染）</span><br><span class="line">可以从网站抓取内容</span><br><span class="line">自动化表单提交、UI测试、键盘输入等</span><br><span class="line">帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例</span><br><span class="line">捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题</span><br></pre></td></tr></table></figure>
<p>安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer --save</span><br></pre></td></tr></table></figure></p>
<h1 id="小试牛刀-生成网页截图"><a href="#小试牛刀-生成网页截图" class="headerlink" title="小试牛刀-生成网页截图"></a>小试牛刀-生成网页截图</h1><p>puppeteer安装完成之后，我们先来个小demo练练手，对指定网站进行截图，拿baidu网试试吧。创建screenshot.js文件，贴入以下代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载先前安装的 puppeteer</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPic</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建chrome实例</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch()</span><br><span class="line">  <span class="comment">// 打开一个新的选项卡</span></span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">  <span class="comment">// 设置页面宽高</span></span><br><span class="line">  page.setViewport(&#123;</span><br><span class="line">    width: <span class="number">1920</span>,</span><br><span class="line">    height: <span class="number">2000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 在我们创建的这个选项卡下，转到baidu网首页</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">  <span class="comment">// 在当前目录下生成nd.png截图</span></span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'nd.png'</span>&#125;)</span><br><span class="line">  <span class="comment">// 最后，关闭浏览器</span></span><br><span class="line">  <span class="keyword">await</span> browser.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPic()</span><br></pre></td></tr></table></figure></p>
<h1 id="爬虫实践"><a href="#爬虫实践" class="headerlink" title="爬虫实践"></a>爬虫实践</h1><p>我们可以轻易地想到，puppeteer功能如此强大，用来做爬虫是再好不过了。接下来的内容也是我自己的实践:网易云音乐的歌曲下面总是有各种各样的神评论，所以我打算用puppeteer来收集一下云音乐的评论。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们的需求是输入一个音乐人的主页链接，收集这个音乐人下的所有热门单曲的所有评论。例如音乐人赵雷的主页下有47首热门单曲，他的主页是<a href="http://music.163.com/#/artist?id=6731，接下来我们一步一步实现。" target="_blank" rel="noopener">http://music.163.com/#/artist?id=6731，接下来我们一步一步实现。</a></p>
<h2 id="分析音乐人主页的DOM结构"><a href="#分析音乐人主页的DOM结构" class="headerlink" title="分析音乐人主页的DOM结构"></a>分析音乐人主页的DOM结构</h2><p>我们发现主页的整个页面是由一个iframe包裹的，iframe中有一个id是song-list-pre-cache的div，该div下有一个table，table下的每一个a标签，就是每一首歌的url以及歌名了。</p>
<h2 id="获取主页歌曲列表"><a href="#获取主页歌曲列表" class="headerlink" title="获取主页歌曲列表"></a>获取主页歌曲列表</h2><p>这一步开始前，我们先分析一下具体操作步骤：打开音乐人主页-&gt;取到对应iframe-&gt;取到id为song-list-pre-cache的节点-&gt;遍历所有的a标签节点-&gt;取到歌曲的url和名称。</p>
<p>关于分析DOM结构，我这里使用cheerio，其简介为“为服务器特别定制的，快速、灵活的jQuery核心实现”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">'http://music.163.com/#'</span></span><br><span class="line"></span><br><span class="line">puppeteer</span><br><span class="line">    .launch(&#123;<span class="attr">headless</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">        page.setViewport(&#123;<span class="attr">width</span>: <span class="number">1367</span>, <span class="attr">height</span>: <span class="number">768</span>&#125;)</span><br><span class="line">        <span class="comment">// 在网络连接数为0时，再进行下一步操作，确保页面加载完成</span></span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="string">`<span class="subst">$&#123;host&#125;</span>/artist?id=6731`</span>, &#123;<span class="attr">waitUntil</span>: <span class="string">'networkidle0'</span>&#125;)</span><br><span class="line">        <span class="keyword">const</span> frames = <span class="keyword">await</span> page.frames()</span><br><span class="line">        <span class="comment">// 取到目标iframe</span></span><br><span class="line">        <span class="keyword">const</span> targetFrame = frames.find(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> frame.name() === <span class="string">'contentFrame'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> targetFrame.content()</span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(content)</span><br><span class="line">        <span class="keyword">const</span> $list = $(<span class="string">'#song-list-pre-cache'</span>)</span><br><span class="line">        <span class="comment">// 遍历a标签，并取到其中的对应属性，作为歌曲的链接和名称</span></span><br><span class="line">        <span class="keyword">const</span> songList = $list</span><br><span class="line">            .find(<span class="string">'a'</span>)</span><br><span class="line">            .map(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> href = $(elem).attr(<span class="string">'href'</span>)</span><br><span class="line">                <span class="keyword">if</span> (_.startsWith(href, <span class="string">'/song?id='</span>)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> title = $(elem).find(<span class="string">'b'</span>).attr(<span class="string">'title'</span>)</span><br><span class="line">                    <span class="keyword">return</span> &#123;href, title&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .get()</span><br><span class="line">        <span class="comment">// 打印歌曲列表</span></span><br><span class="line">        <span class="built_in">console</span>.log(songList)</span><br><span class="line">        <span class="keyword">await</span> browser.close()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; <span class="attr">href</span>: <span class="string">'/song?id=436514312'</span>, <span class="attr">title</span>: <span class="string">'成都'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202373'</span>, <span class="attr">title</span>: <span class="string">'南方姑娘'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567189'</span>, <span class="attr">title</span>: <span class="string">'理想'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567193'</span>, <span class="attr">title</span>: <span class="string">'我们的时光'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202369'</span>, <span class="attr">title</span>: <span class="string">'画'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567192'</span>, <span class="attr">title</span>: <span class="string">'少年锦时'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447925059'</span>, <span class="attr">title</span>: <span class="string">'阿刁 - (Diao)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447926067'</span>, <span class="attr">title</span>: <span class="string">'鼓楼 - (The Drum Tower)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567191'</span>, <span class="attr">title</span>: <span class="string">'三十岁的女人'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447925066'</span>, <span class="attr">title</span>: <span class="string">'八十年代的歌 - (Song Of The 80s)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=33166602'</span>, <span class="attr">title</span>: <span class="string">'让我偷偷看你'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447926063'</span>, <span class="attr">title</span>: <span class="string">'朵 - (Dorr)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=437608773'</span>, <span class="attr">title</span>: <span class="string">'无法长大'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=530995556'</span>, <span class="attr">title</span>: <span class="string">'十九岁 - (At The Age of Nineteen)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567187'</span>, <span class="attr">title</span>: <span class="string">'吉姆餐厅'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447925058'</span>, <span class="attr">title</span>: <span class="string">'玛丽 - (Mary)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=1295824647'</span>, <span class="attr">title</span>: <span class="string">'彩虹下面 - (电影《西虹市首富》推广曲)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567188'</span>, <span class="attr">title</span>: <span class="string">'家乡'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=28111471'</span>, <span class="attr">title</span>: <span class="string">'已是两条路上的人'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=517567264'</span>, <span class="attr">title</span>: <span class="string">'静下来'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202368'</span>, <span class="attr">title</span>: <span class="string">'未给姐姐递出的信'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567190'</span>, <span class="attr">title</span>: <span class="string">'梦中的哈德森'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567185'</span>, <span class="attr">title</span>: <span class="string">'北京的冬天'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=34852810'</span>, <span class="attr">title</span>: <span class="string">'再也不会去丽江'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447925067'</span>, <span class="attr">title</span>: <span class="string">'再见北京 - (Goodbye! Beijing!)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567194'</span>, <span class="attr">title</span>: <span class="string">'小屋'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202367'</span>, <span class="attr">title</span>: <span class="string">'人家'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202377'</span>, <span class="attr">title</span>: <span class="string">'妈妈'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202376'</span>, <span class="attr">title</span>: <span class="string">'背影'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447925063'</span>, <span class="attr">title</span>: <span class="string">'孤独 - (Left Alone)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29567186'</span>, <span class="attr">title</span>: <span class="string">'浮游'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202370'</span>, <span class="attr">title</span>: <span class="string">'不开的唇'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202375'</span>, <span class="attr">title</span>: <span class="string">'开往北京的火车'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=447926068'</span>, <span class="attr">title</span>: <span class="string">'窑上路 - (Yao-shang Road)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202371'</span>, <span class="attr">title</span>: <span class="string">'赵小雷'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=29810320'</span>, <span class="attr">title</span>: <span class="string">'未给姐姐递出的信 '</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=433018041'</span>, <span class="attr">title</span>: <span class="string">'民谣'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=202374'</span>, <span class="attr">title</span>: <span class="string">'Over'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=553546118'</span>, <span class="attr">title</span>: <span class="string">'朵儿 (Live版)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=1327930869'</span>, <span class="attr">title</span>: <span class="string">'1三十岁的女人（Cover：赵雷）'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=460628183'</span>, <span class="attr">title</span>: <span class="string">'月亮粑粑 (Live)'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=432792901'</span>, <span class="attr">title</span>: <span class="string">'凭什么说爱你'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=433018045'</span>, <span class="attr">title</span>: <span class="string">'往事只能回味'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=31460216'</span>, <span class="attr">title</span>: <span class="string">'米店'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=432792905'</span>, <span class="attr">title</span>: <span class="string">'夏天'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=433018044'</span>, <span class="attr">title</span>: <span class="string">'爱人你在哪里'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=433018046'</span>, <span class="attr">title</span>: <span class="string">'逆流而上'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=433018047'</span>, <span class="attr">title</span>: <span class="string">'飞来飞去'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=432792903'</span>, <span class="attr">title</span>: <span class="string">'塔吉汗'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">href</span>: <span class="string">'/song?id=432792904'</span>, <span class="attr">title</span>: <span class="string">'何必'</span> &#125; ]</span><br></pre></td></tr></table></figure>
<h2 id="跳转到歌曲页面"><a href="#跳转到歌曲页面" class="headerlink" title="跳转到歌曲页面"></a>跳转到歌曲页面</h2><p>在上一步，我们拿到了歌曲的url，那么接下来自然就是跳转到每首歌的页面，进行评论抓取了。</p>
<p>歌曲页面的DOM结构和音乐人页面很类似，也有一个iframe，iframe中有一个id为comment-box的div节点，在这个节点在遍历class为itm的div节点，在itm下，通过具体分析，我们就能取到用户名和评论内容了。关于热评和最新评论，我们先简单处理，不区分。</p>
<p>我们将每首歌第一页的评论都写在content.html文件中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">const</span> he = <span class="built_in">require</span>(<span class="string">'he'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">'http://music.163.com/#'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象出抓取评论的函数，便于进一步开发</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; sTargetFrame </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> collectCommentList = <span class="keyword">async</span>(sTargetFrame) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sContent = <span class="keyword">await</span> sTargetFrame.content()</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(sContent)</span><br><span class="line">    <span class="keyword">const</span> res = $(<span class="string">'#comment-box'</span>)</span><br><span class="line">        .find(<span class="string">'.itm'</span>)</span><br><span class="line">        .map(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> brk = $(elem).find(<span class="string">'.cntwrap .f-brk'</span>)</span><br><span class="line">            <span class="keyword">const</span> brkText = brk.text()</span><br><span class="line">            <span class="comment">// 用户名</span></span><br><span class="line">            <span class="keyword">const</span> username = $(brk)</span><br><span class="line">                .find(<span class="string">'a'</span>)</span><br><span class="line">                .text()</span><br><span class="line">            <span class="comment">// 评论字符串</span></span><br><span class="line">            <span class="keyword">const</span> commentStr = $(brk)</span><br><span class="line">                .text()</span><br><span class="line">                .replace(username, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;username, commentStr&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .get()</span><br><span class="line">    fs.appendFileSync(<span class="string">'./song.txt'</span>, <span class="built_in">JSON</span>.stringify(res) + <span class="string">'\n'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puppeteer</span><br><span class="line">    .launch(&#123;<span class="attr">headless</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">        page.setViewport(&#123;<span class="attr">width</span>: <span class="number">1367</span>, <span class="attr">height</span>: <span class="number">768</span>&#125;)</span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="string">`<span class="subst">$&#123;host&#125;</span>/artist?id=6731`</span>, &#123;<span class="attr">waitUntil</span>: <span class="string">'networkidle0'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> frames = <span class="keyword">await</span> page.frames()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> targetFrame = frames.find(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> frame.name() === <span class="string">'contentFrame'</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> targetFrame.content()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> $list = $(<span class="string">'#song-list-pre-cache'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> songList = $list</span><br><span class="line">            .find(<span class="string">'a'</span>)</span><br><span class="line">            .map(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> href = $(elem).attr(<span class="string">'href'</span>)</span><br><span class="line">                <span class="keyword">if</span> (_.startsWith(href, <span class="string">'/song?id='</span>)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> title = $(elem).find(<span class="string">'b'</span>).attr(<span class="string">'title'</span>)</span><br><span class="line">                    <span class="keyword">return</span> &#123;href, title&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .get()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> songItem</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`一共<span class="subst">$&#123;songList.length&#125;</span>首歌`</span>)</span><br><span class="line">        <span class="keyword">while</span> (songItem = songList[index++]) &#123;</span><br><span class="line">            <span class="keyword">const</span> sPage = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`正在收集<span class="subst">$&#123;songItem.title&#125;</span>下的评论`</span>)</span><br><span class="line">            <span class="keyword">await</span> sPage.goto(<span class="string">`<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;songItem.href&#125;</span>`</span>, &#123;</span><br><span class="line">                waitUntil: <span class="string">'networkidle2'</span>,</span><br><span class="line">                timeout: <span class="number">0</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">const</span> sFrames = <span class="keyword">await</span> sPage.frames()</span><br><span class="line">            <span class="keyword">const</span> sTargetFrame = sFrames.find(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> frame.name() === <span class="string">'contentFrame'</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> commentList = <span class="keyword">await</span> collectCommentList(sTargetFrame)</span><br><span class="line"></span><br><span class="line">            sPage.close()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> browser.close()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经可以抓取每一首歌的第一页评论了，但是这远远不够，一首热门歌曲往往有上万条评论，这就需要翻页抓取了。</p>
<h2 id="评论翻页"><a href="#评论翻页" class="headerlink" title="评论翻页"></a>评论翻页</h2><p>puppeteer功能强大，模拟按钮点击功能当然也不在话下。所以我们接下来要做的事情就是点击下一页按钮后，再重复一次抓取动作即可。</p>
<p>避免篇幅过大，我这里贴出主要的翻页代码，完整代码会在文末给出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> commentList = <span class="keyword">await</span> collectCommentList(sTargetFrame)</span><br><span class="line">  <span class="keyword">let</span> nextBtnHandler = <span class="keyword">await</span> sTargetFrame.$(<span class="string">'.znxt'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!nextBtnHandler) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  nextBtnHandler.click()</span><br><span class="line">  <span class="comment">// 关于如何判断评论加载完成，这里还没有找到更好的方案，所以暂时做一个 sleep 处理</span></span><br><span class="line">  <span class="keyword">await</span> timeout(<span class="number">1500</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">await</span> isBtnAbled(sTargetFrame))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commentList = <span class="keyword">await</span> collectCommentList(sTargetFrame)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBtnAbled = <span class="keyword">async</span>(sTargetFrame, className) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sContent = <span class="keyword">await</span> sTargetFrame.content()</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(sContent)</span><br><span class="line">    <span class="keyword">return</span> !$(<span class="string">'.znxt'</span>).hasClass(<span class="string">'js-disabled'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> he = <span class="built_in">require</span>(<span class="string">'he'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">'http://music.163.com/#'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> collectCommentList = <span class="keyword">async</span>(sTargetFrame) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sContent = <span class="keyword">await</span> sTargetFrame.content();</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(sContent);</span><br><span class="line">    <span class="keyword">const</span> res = $(<span class="string">'#comment-box'</span>).find(<span class="string">'.itm'</span>).map(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> brk = $(elem).find(<span class="string">'.cntwrap .f-brk'</span>);</span><br><span class="line">        <span class="keyword">const</span> brkText = he.decode(brk.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        <span class="keyword">const</span> username = $(brk)</span><br><span class="line">            .find(<span class="string">'a'</span>)</span><br><span class="line">            .text();</span><br><span class="line">        <span class="comment">// 评论字符串</span></span><br><span class="line">        <span class="keyword">const</span> commentStr = $(brk)</span><br><span class="line">            .text()</span><br><span class="line">            .replace(username, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; username, commentStr &#125;;</span><br><span class="line">    &#125;).get();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">    fs.appendFileSync(<span class="string">'./song.txt'</span>, <span class="built_in">JSON</span>.stringify(res) + <span class="string">'\n'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isBtnAbled = <span class="keyword">async</span>(sTargetFrame, className) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sContent = <span class="keyword">await</span> sTargetFrame.content();</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(sContent);</span><br><span class="line">    <span class="keyword">return</span> !$(<span class="string">'.znxt'</span>).hasClass(<span class="string">'js-disabled'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// args: ['--no-sandbox'] ubuntu下启动失败的问题</span></span><br><span class="line">puppeteer</span><br><span class="line">    .launch(&#123; <span class="attr">headless</span>: <span class="literal">true</span>, <span class="attr">args</span>: [<span class="string">'--no-sandbox'</span>] &#125;)</span><br><span class="line">    .then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">        page.setViewport(&#123; <span class="attr">width</span>: <span class="number">1367</span>, <span class="attr">height</span>: <span class="number">768</span> &#125;);</span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="string">`<span class="subst">$&#123;host&#125;</span>/artist?id=6731`</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">'networkidle0'</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> frames = <span class="keyword">await</span> page.frames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> targetFrame = frames.find(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> frame.name() === <span class="string">'contentFrame'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> targetFrame.content();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> $list = $(<span class="string">'#song-list-pre-cache'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> songList = $list.find(<span class="string">'a'</span>).map(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> href = $(elem).attr(<span class="string">'href'</span>);</span><br><span class="line">            <span class="keyword">if</span> (_.startsWith(href, <span class="string">'/song?id='</span>)) &#123;</span><br><span class="line">                <span class="keyword">const</span> title = he.decode($(elem).find(<span class="string">'b'</span>).attr(<span class="string">'title'</span>));</span><br><span class="line">                <span class="keyword">return</span> &#123; href, title &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> songItem;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`一共<span class="subst">$&#123;songList.length&#125;</span>首歌`</span>);</span><br><span class="line">        <span class="keyword">while</span> (songItem = songList[index++]) &#123;</span><br><span class="line">            <span class="keyword">const</span> sPage = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`正在收集<span class="subst">$&#123;songItem.title&#125;</span>下的评论`</span>);</span><br><span class="line">            <span class="keyword">await</span> sPage.goto(<span class="string">`<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;songItem.href&#125;</span>`</span>, &#123;</span><br><span class="line">                waitUntil: <span class="string">'networkidle2'</span>,</span><br><span class="line">                timeout: <span class="number">0</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> sFrames = <span class="keyword">await</span> sPage.frames();</span><br><span class="line">            <span class="keyword">const</span> sTargetFrame = sFrames.find(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> frame.name() === <span class="string">'contentFrame'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> commentList = <span class="keyword">await</span> collectCommentList(sTargetFrame);</span><br><span class="line">                <span class="keyword">let</span> nextBtnHandler = <span class="keyword">await</span> sTargetFrame.$(<span class="string">'.znxt'</span>);</span><br><span class="line">                <span class="keyword">if</span> (!nextBtnHandler) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nextBtnHandler.click();</span><br><span class="line">                <span class="keyword">await</span> timeout(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="keyword">await</span> isBtnAbled(sTargetFrame));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> commentList = <span class="keyword">await</span> collectCommentList(sTargetFrame);</span><br><span class="line"></span><br><span class="line">            sPage.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> browser.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fs.appendFile('./content.html', JSON.stringify(songList), (err) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">// console.log(err); &#125;); other actions... await browser.close();</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/node-superagent模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/node-superagent模块/" itemprop="url">node superagent模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T15:48:59+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/node-superagent模块/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/node-superagent模块/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SuperAgent"><a href="#SuperAgent" class="headerlink" title="SuperAgent"></a>SuperAgent</h1><p>superagent 是一个轻量的,渐进式的ajax api,可读性好,学习曲线低,内部依赖nodejs原生的请求api,适用于nodejs环境下.</p>
<p>安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i superagent --save</span><br></pre></td></tr></table></figure></p>
<p>一个简单的post请求，并设置请求头信息的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">   .post(<span class="string">'/api/pet'</span>)</span><br><span class="line">   .send(&#123; <span class="attr">name</span>: <span class="string">'Manny'</span>, <span class="attr">species</span>: <span class="string">'cat'</span> &#125;)</span><br><span class="line">   .set(<span class="string">'X-API-Key'</span>, <span class="string">'foobar'</span>)</span><br><span class="line">   .set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">   .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">       alert(<span class="string">'yay got '</span> + <span class="built_in">JSON</span>.stringify(res.body));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       alert(<span class="string">'Oh no! error '</span> + res.text);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="请求基础"><a href="#请求基础" class="headerlink" title="请求基础"></a>请求基础</h2><p>一个请求的初始化可以用请求对象里合适的方法来执行，然后调用end()来发送请求,下面是一个简单的get请求:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.get(<span class="string">'/search'</span>).end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>请求方法也可以通过参数传递:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(<span class="string">'GET'</span>, <span class="string">'/search'</span>).end(callback);</span><br></pre></td></tr></table></figure>
<p>node客户端也允许提供绝对路径:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.get(<span class="string">'http://example.com/search'</span>).end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>delete,head,post,put和别的http动作都可以使用,来换个方法看看:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.head(<span class="string">'/favicon.ico'</span>).end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>delete是一个特列,因为它是系统保留的关键字,所以应该用.del()这个名字:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.del(<span class="string">'/user/1'</span>).end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>http请求默认的方法为get,所以就像你看到的,下面的这个例子也是可用的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(<span class="string">'/search'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123; &#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="设置头字段"><a href="#设置头字段" class="headerlink" title="设置头字段"></a>设置头字段</h1><p>设置头字段非常简单，只需调用.set()方法，传递一个名称和值就行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">   .get(<span class="string">'/search'</span>)</span><br><span class="line">   .set(<span class="string">'API-Key'</span>, <span class="string">'foobar'</span>)</span><br><span class="line">   .set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">   .end(callback);</span><br></pre></td></tr></table></figure>
<p>一次就可以修改多个头字段:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">   .get(<span class="string">'/search'</span>)</span><br><span class="line">   .set(&#123; <span class="string">'API-Key'</span>: <span class="string">'foobar'</span>, <span class="attr">Accept</span>: <span class="string">'application/json'</span> &#125;)</span><br><span class="line">   .end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h1><p>当使用get请求传递查询字符串的时候，用.query()方法,传递一个对象就可以,下面的代码将产生一个/search?query=Manny&amp;range=1..5&amp;order=desc请求:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">   .get(<span class="string">'/search'</span>)</span><br><span class="line">   .query(&#123; <span class="attr">query</span>: <span class="string">'Manny'</span> &#125;)</span><br><span class="line">   .query(&#123; <span class="attr">range</span>: <span class="string">'1..5'</span> &#125;)</span><br><span class="line">   .query(&#123; <span class="attr">order</span>: <span class="string">'desc'</span> &#125;)</span><br><span class="line">   .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>或者传一个单独的大对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .get(<span class="string">'/search'</span>)</span><br><span class="line">  .query(&#123; <span class="attr">query</span>: <span class="string">'Manny'</span>, <span class="attr">range</span>: <span class="string">'1..5'</span>, <span class="attr">order</span>: <span class="string">'desc'</span> &#125;)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>.query()方法也允许传递字符串:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">    .get(<span class="string">'/querystring'</span>)</span><br><span class="line">    .query(<span class="string">'search=Manny&amp;range=1..5'</span>)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>或者字符串拼接:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">    .get(<span class="string">'/querystring'</span>)</span><br><span class="line">    .query(<span class="string">'search=Manny'</span>)</span><br><span class="line">    .query(<span class="string">'range=1..5'</span>)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="POST-PUT请求"><a href="#POST-PUT请求" class="headerlink" title="POST/PUT请求"></a>POST/PUT请求</h1><p>一个典型的json post请求看起来就像下面的那样，设置一个合适的Content-type头字段，然后写入一些数据，在这个例子里只是json字符串:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>)</span><br><span class="line">    .set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">    .send(<span class="string">'&#123;"name":"tj","pet":"tobi"&#125;'</span>)</span><br><span class="line">    .end(callback)</span><br></pre></td></tr></table></figure></p>
<p>因为json非常通用，所以就作为默认的Content-type,下面的例子跟上面的一样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>)</span><br><span class="line">    .send(&#123; <span class="attr">name</span>: <span class="string">'tj'</span>, <span class="attr">pet</span>: <span class="string">'tobi'</span> &#125;)</span><br><span class="line">    .end(callback)</span><br></pre></td></tr></table></figure></p>
<p>或者调用多次.send()方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>)</span><br><span class="line">    .send(&#123; <span class="attr">name</span>: <span class="string">'tj'</span> &#125;)</span><br><span class="line">    .send(&#123; <span class="attr">pet</span>: <span class="string">'tobi'</span> &#125;)</span><br><span class="line">    .end(callback)</span><br></pre></td></tr></table></figure></p>
<p>默认发送字符串，将设置Content-type为application/x-www-form-urlencoded,多次调用将会通过&amp;来连接，这里的结果为name=tj&amp;pet=tobi:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>)</span><br><span class="line">    .send(<span class="string">'name=tj'</span>)</span><br><span class="line">    .send(<span class="string">'pet=tobi'</span>)</span><br><span class="line">    .end(callback);</span><br></pre></td></tr></table></figure>
<p>superagent的请求数据格式化是可以扩展的，不过默认支持form和json两种格式,想发送数据以application/x-www-form-urlencoded类型的话，则可以简单的调用.type()方法传递form参数就行，这里默认是json,下面的请求将会postname=tj&amp;pet=tobi内容:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>)</span><br><span class="line">    .type(<span class="string">'form'</span>)</span><br><span class="line">    .send(&#123; <span class="attr">name</span>: <span class="string">'tj'</span> &#125;)</span><br><span class="line">    .send(&#123; <span class="attr">pet</span>: <span class="string">'tobi'</span> &#125;)</span><br><span class="line">    .end(callback)</span><br></pre></td></tr></table></figure></p>
<p>注意:form是form-data和urlencoded的别名,为了向后兼容</p>
<h1 id="设置Content-Type"><a href="#设置Content-Type" class="headerlink" title="设置Content-Type"></a>设置Content-Type</h1><p>常见的方案是使用.set()方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>).set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure></p>
<p>一个简便的方法是调用.type()方法，传递一个规范的MIME名称，包括type/subtype,或者一个简单的后缀就像xml,json,png这样，例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.post(<span class="string">'/user'</span>).type(<span class="string">'application/json'</span>)</span><br><span class="line">request.post(<span class="string">'/user'</span>).type(<span class="string">'json'</span>)</span><br><span class="line">request.post(<span class="string">'/user'</span>).type(<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="设置接受类型"><a href="#设置接受类型" class="headerlink" title="设置接受类型"></a>设置接受类型</h1><p>跟.type()简便方法一样，这里也可以调用.accept()方法来设置接受类型，这个值将会被request.types所引用，支持传递一个规范的MIME名称，包括type/subtype,或者一个简单的后缀就像xml,json,png这样,例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.get(<span class="string">'/user'</span>).accept(<span class="string">'application/json'</span>)</span><br><span class="line">request.get(<span class="string">'/user'</span>).accept(<span class="string">'json'</span>)</span><br><span class="line">request.get(<span class="string">'/user'</span>).accept(<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h1><p>当用.send(obj)方法来发送一个post请求，并且希望传递一些查询字符串，可以调用.query()方法,比如向?format=json&amp;dest=/login发送post请求:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .post(<span class="string">'/'</span>)</span><br><span class="line">  .query(&#123; <span class="attr">format</span>: <span class="string">'json'</span> &#125;)</span><br><span class="line">  .query(&#123; <span class="attr">dest</span>: <span class="string">'/login'</span> &#125;)</span><br><span class="line">  .send(&#123; <span class="attr">post</span>: <span class="string">'data'</span>, <span class="attr">here</span>: <span class="string">'wahoo'</span> &#125;)</span><br><span class="line">  .end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="解析响应内容"><a href="#解析响应内容" class="headerlink" title="解析响应内容"></a>解析响应内容</h1><p>superagent会解析一些常用的格式给请求者，当前支持application/x-www-form-urlencoded,application/json,multipart/form-data.</p>
<h1 id="JSON-Urlencoded"><a href="#JSON-Urlencoded" class="headerlink" title="JSON/Urlencoded"></a>JSON/Urlencoded</h1><p>res.body是解析后的内容对象,比如一个请求响应’{“user”:{“name”:”tobi”}}’字符串,res.body.user.name将会返回tobi,同样的，x-www-form-urlencoded格式的user[name]=tobi解析完的值，也是一样的.</p>
<h1 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h1><p>nodejs客户端通过Formidable模块来支持multipart/form-data类型,当解析一个multipart响应时,res.files属性就可以用.假设一个请求响应下面的数据:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--whoop</span><br><span class="line">Content-Disposition: attachment; name=<span class="string">"image"</span>; filename=<span class="string">"tobi.png"</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">... data here ...</span><br><span class="line">--whoop</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"name"</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Tobi</span><br><span class="line">--whoop--</span><br></pre></td></tr></table></figure>
<p>你将可以获取到res.body.name名为’Tobi’,res.files.image为一个file对象,包括一个磁盘文件路径，文件名称，还有其它的文件属性.</p>
<h1 id="响应属性"><a href="#响应属性" class="headerlink" title="响应属性"></a>响应属性</h1><p>响应一般会提供很多有用的标识以及属性,都在response对象里，按照respone.text,解析后的response.body,头字段，一些标识的顺序来排列.</p>
<h1 id="Response-text"><a href="#Response-text" class="headerlink" title="Response text"></a>Response text</h1><p>res.text包含未解析前的响应内容，一般只在mime类型能够匹配text/,json,x-www-form-urlencoding的情况下，默认为nodejs客户端提供,这是为了节省内存.因为当响应以文件或者图片大内容的情况下影响性能.</p>
<h1 id="Response-body"><a href="#Response-body" class="headerlink" title="Response body"></a>Response body</h1><p>跟请求数据自动序列化一样，响应数据也会自动的解析，当为一个Content-Type定义一个解析器后，就能自动解析，默认解析包含application/json和application/x-www-form-urlencoded,可以通过访问res.body来访问解析对象.</p>
<h1 id="Response-header-fields"><a href="#Response-header-fields" class="headerlink" title="Response header fields"></a>Response header fields</h1><p>res.header包含解析之后的响应头数据,键值都是node处理成小写字母形式，比如res.header[‘content-length’].</p>
<h1 id="Response-Content-Type"><a href="#Response-Content-Type" class="headerlink" title="Response Content-Type"></a>Response Content-Type</h1><p>Content-Type响应头字段是一个特列，服务器提供res.type来访问它，默认res.charset是空的,如果有的话，则自动填充，例如Content-Type值为text/html; charset=utf8,则res.type为text/html,res.charst为utf8.</p>
<h1 id="Response-status"><a href="#Response-status" class="headerlink" title="Response status"></a>Response status</h1><p>响应状态标识可以用来判断请求是否成功，除此之外，可以用superagent来构建理想的restful服务器,这些标识目前定义为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = status / <span class="number">100</span> | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// status / class</span></span><br><span class="line"> res.status = status;</span><br><span class="line"> res.statusType = type;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// basics</span></span><br><span class="line"> res.info = <span class="number">1</span> == type;</span><br><span class="line"> res.ok = <span class="number">2</span> == type;</span><br><span class="line"> res.clientError = <span class="number">4</span> == type;</span><br><span class="line"> res.serverError = <span class="number">5</span> == type;</span><br><span class="line"> res.error = <span class="number">4</span> == type || <span class="number">5</span> == type;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// sugar</span></span><br><span class="line"> res.accepted = <span class="number">202</span> == status;</span><br><span class="line"> res.noContent = <span class="number">204</span> == status || <span class="number">1223</span> == status;</span><br><span class="line"> res.badRequest = <span class="number">400</span> == status;</span><br><span class="line"> res.unauthorized = <span class="number">401</span> == status;</span><br><span class="line"> res.notAcceptable = <span class="number">406</span> == status;</span><br><span class="line"> res.notFound = <span class="number">404</span> == status;</span><br><span class="line"> res.forbidden = <span class="number">403</span> == status;</span><br></pre></td></tr></table></figure></p>
<h1 id="中止请求"><a href="#中止请求" class="headerlink" title="中止请求"></a>中止请求</h1><p>可以通过req.abort()来中止请求.</p>
<h1 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h1><p>可以通过req.timeout()来定义超时时间,然后当超时错误发生时，为了区别于别的错误,err.timeout属性被定义为超时时间,注意,当超时错误发生后，后续的请求都会被重定向.不是每个请求.</p>
<h1 id="基础验证"><a href="#基础验证" class="headerlink" title="基础验证"></a>基础验证</h1><p>nodejs客户端可以通过两种方式来达到验证的目的,第一个是传递一个像这样的url,user:pass:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.get(<span class="string">'http://tobi:learnboost[@local](/user/local)'</span>).end(callback);</span><br></pre></td></tr></table></figure></p>
<p>第二种是调用.auth()方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .get(<span class="string">'http://local'</span>)</span><br><span class="line">  .auth(<span class="string">'tobo'</span>, <span class="string">'learnboost'</span>)</span><br><span class="line">  .end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="跟随重定向"><a href="#跟随重定向" class="headerlink" title="跟随重定向"></a>跟随重定向</h1><p>默认是向上跟随5个重定向，不过可以通过调用.res.redirects(n)来设置个数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .get(<span class="string">'/some.png'</span>)</span><br><span class="line">  .redirects(<span class="number">2</span>)</span><br><span class="line">  .end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="管道数据"><a href="#管道数据" class="headerlink" title="管道数据"></a>管道数据</h1><p>nodejs客户端允许使用一个请求流来输送数据,比如请求一个文件作为输出流:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'path/to/my.json'</span>);</span><br><span class="line"><span class="keyword">var</span> req = request.post(<span class="string">'/somewhere'</span>);</span><br><span class="line">req.type(<span class="string">'json'</span>);</span><br><span class="line">stream.pipe(req);</span><br></pre></td></tr></table></figure></p>
<p>或者输送一个响应流到文件中:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = fs.createWriteStream(<span class="string">'path/to/my.json'</span>);</span><br><span class="line"><span class="keyword">var</span> req = request.get(<span class="string">'/some.json'</span>);</span><br><span class="line">req.pipe(stream);</span><br></pre></td></tr></table></figure></p>
<h1 id="复合请求"><a href="#复合请求" class="headerlink" title="复合请求"></a>复合请求</h1><p>superagent用来构建复合请求非常不错,提供了低级和高级的api方法.</p>
<p>低级的api是使用多个部分来表现一个文件或者字段，.part()方法返回一个新的部分,提供了跟request本身相似的api方法.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = request.post(<span class="string">'/upload'</span>);</span><br><span class="line"></span><br><span class="line">req.part()</span><br><span class="line">   .set(<span class="string">'Content-Type'</span>, <span class="string">'image/png'</span>)</span><br><span class="line">   .set(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment; filename="myimage.png"'</span>)</span><br><span class="line">   .write(<span class="string">'some image data'</span>)</span><br><span class="line">   .write(<span class="string">'some more image data'</span>);</span><br><span class="line"></span><br><span class="line">req.part()</span><br><span class="line">   .set(<span class="string">'Content-Disposition'</span>, <span class="string">'form-data; name="name"'</span>)</span><br><span class="line">   .set(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)</span><br><span class="line">   .write(<span class="string">'tobi'</span>);</span><br><span class="line"></span><br><span class="line">req.end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="附加文件"><a href="#附加文件" class="headerlink" title="附加文件"></a>附加文件</h1><p>上面提及的高级api方法，可以通用.attach(name, [path], [filename])和.field(name, value)这两种形式来调用.添加多个附件也比较简单，只需要给附件提供自定义的文件名称,同样的基础名称也要提供.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .post(<span class="string">'/upload'</span>)</span><br><span class="line">  .attach(<span class="string">'avatar'</span>, <span class="string">'path/to/tobi.png'</span>, <span class="string">'user.png'</span>)</span><br><span class="line">  .attach(<span class="string">'image'</span>, <span class="string">'path/to/loki.png'</span>)</span><br><span class="line">  .attach(<span class="string">'file'</span>, <span class="string">'path/to/jane.png'</span>)</span><br><span class="line">  .end(callback);</span><br></pre></td></tr></table></figure></p>
<h1 id="字段值"><a href="#字段值" class="headerlink" title="字段值"></a>字段值</h1><p>跟html的字段很像,你可以调用.field(name,value)方法来设置字段,假设你想上传一个图片的时候带上自己的名称和邮箱，那么你可以像下面写的那样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">   .post(<span class="string">'/upload'</span>)</span><br><span class="line">   .field(<span class="string">'user[name]'</span>, <span class="string">'Tobi'</span>)</span><br><span class="line">   .field(<span class="string">'user[email]'</span>, <span class="string">'tobi[@learnboost](/user/learnboost).com'</span>)</span><br><span class="line">   .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)</span><br><span class="line">   .end(callback);</span><br></pre></td></tr></table></figure>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><p>nodejs客户端本身就提供了压缩响应内容，所以你不需要做任何其它事情.</p>
<h1 id="缓冲响应"><a href="#缓冲响应" class="headerlink" title="缓冲响应"></a>缓冲响应</h1><p>为了强迫缓冲res.text这样的响应内容,可以调用req.buffer()方法,想取消默认的文本缓冲响应像text/plain,text/html这样的，可以调用req.buffer(false)方法</p>
<p>当缓冲res.buffered标识提供了，那么就可以在一个回调函数里处理缓冲和没缓冲的响应.</p>
<h1 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h1><p>.withCredentials()方法可以激活发送原始cookie的能力,不过只有在Access-Control-Allow-Origin不是一个通配符(*),并且Access-Control-Allow-Credentials为’true’的情况下才行.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .get(<span class="string">'http://localhost:4001/'</span>)</span><br><span class="line">  .withCredentials()</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    assert(<span class="number">200</span> == res.status);</span><br><span class="line">    assert(<span class="string">'tobi'</span> == res.text);</span><br><span class="line">    next();</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>当发送错误时，superagent首先会检查回调函数的参数数量,当err参数提供的话，参数就是两个,如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line"> .post(<span class="string">'/upload'</span>)</span><br><span class="line"> .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)</span><br><span class="line"> .end(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当省略了回调函数,或者回调只有一个参数的话,可以添加error事件的处理.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request</span><br><span class="line">  .post(<span class="string">'/upload'</span>)</span><br><span class="line">  .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)</span><br><span class="line">  .on(<span class="string">'error'</span>, handle)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意:superagent默认情况下,对响应4xx和5xx的认为不是错误,例如当响应返回一个500或者403的时候,这些状态信息可以通过res.error,res.status和其它的响应属性来查看,但是没有任务的错误对象会传递到回调函数里或者emit一个error事件.正常的error事件只会发生在网络错误,解析错误等.</p>
<p>当产生一个4xx或者5xx的http错误响应,res.error提供了一个错误信息的对象，你可以通过检查这个来做某些事情.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.error) &#123;</span><br><span class="line">  alert(<span class="string">'oh no '</span> + res.error.message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'got '</span> + res.status + <span class="string">' response'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/全面理解-koa-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/全面理解-koa-router/" itemprop="url">全面理解 koa-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T15:18:43+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/全面理解-koa-router/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/全面理解-koa-router/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>koa 框架一直都保持着简洁性, 它只对 node 的 HTTP 模块进行了封装, 而在真正实际使用, 我们还需要更多地像路由这样的模块来构建我们的应用, 而 koa-router 是常用的 koa 的路由库. 这里通过解析 koa-router 的源码来达到深入学习的目的.</p>
<h1 id="深入浅出路由模块"><a href="#深入浅出路由模块" class="headerlink" title="深入浅出路由模块"></a>深入浅出路由模块</h1><p>在 node 原生里面, 如果我们需要实现路由功能, 那么就可以像下面这样编写代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; pathname &#125; = parse(req.url);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">        res.end(<span class="string">'index page'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/test'</span>) &#123;</span><br><span class="line">        res.end(<span class="string">'test page'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'router is not found'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码通过解析原生 request IncomingMessage 的 url 属性, 利用 if…else 判断路径返回不同的结果.<br>但是上面的代码缺点也很明显, 如果路由过多, if…else 的分支也会越庞大, 不利于代码的维护与多人合作.因此,我们需要一个特定的路由模块来统一地模块化地解决路由功能的问题.<br>如果是使用 koa-router 的话, 那么可以借助下面的代码来简单建立一个 koa-router 库的使用 demo:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 创建 router 实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册路由</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'index'</span>);</span><br><span class="line">  ctx.body = <span class="string">'index'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>运行上面的代码, 访问根路由 ‘/‘ 我们可以看到返回数据为 ‘index’, 这说明路由已经基本生效了.<br>我们来看上面的代码, 使用 koa-router 第一步就是新建一个 router 实例对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br></pre></td></tr></table></figure>
<p>然后在构建应用的时候, 我们的首要目标就是创建多个 CGI 接口以适配不同的业务需求, 那么接下来就需要注册对应的路由:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'index'</span>);</span><br><span class="line">  ctx.body = <span class="string">'index'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的示例使用了 GET 方法来进行注册根路由, 实际上不仅可以使用 GET 方法, 还可以使用 POST, DELETE, PUT 等等 node 支持的方法.<br>然后为了让 koa 实例使用我们处理后的路由模块, 我们需要使用 routes 方法将路由加入到应用全局的中间件函数中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br></pre></td></tr></table></figure>
<h1 id="源码架构与解析"><a href="#源码架构与解析" class="headerlink" title="源码架构与解析"></a>源码架构与解析</h1><p>通过上面的代码, 我们已经知道了 koa-router 的简单使用, 接下来我们需要深入到代码中, 理解它是怎么做到匹配从客户端传过来的请求并跳转执行对应的逻辑的.在此之前我们先看一下代码的结构图:<br><img src="http://weixinfactory.di1game.com/blog/router.png"></p>
<h2 id="Router-amp-Layer"><a href="#Router-amp-Layer" class="headerlink" title="Router &amp; Layer"></a>Router &amp; Layer</h2><p>第一步, 我们需要新建一个 Router 的实例对象, 而对于一个 Router 的实例来说理解其属性是至关重要的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Router)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.methods = <span class="keyword">this</span>.opts.methods || [</span><br><span class="line">    <span class="string">'HEAD'</span>,</span><br><span class="line">    <span class="string">'OPTIONS'</span>,</span><br><span class="line">    <span class="string">'GET'</span>,</span><br><span class="line">    <span class="string">'PUT'</span>,</span><br><span class="line">    <span class="string">'PATCH'</span>,</span><br><span class="line">    <span class="string">'POST'</span>,</span><br><span class="line">    <span class="string">'DELETE'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.params = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到, 实际有用的属性不过 3 个, 分别是 methods 数组, params 对象, stack 数组. methods 数组存放的是允许使用的 HTTP 方法名, 会在 Router.prototype.allowedMethods 方法中使用, 我们在创建 Router 实例的时候可以进行配置, 允许使用哪些方法. 而对于 params 对象它存储的是键为参数名与值为对应的参数校验函数, 这样是为了通过在全局存储参数的校验函数, 方便在注册路由的时候为路由的中间件函数数组添加校验函数. 对于 stack 数组, 则是存储每一个路由, 也就是 Layer 的实例对象, 每一个路由都相当于一个 Layer 实例对象.<br>对于 Layer 类来说, 创建一个实例对象用于管理每个路由:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span>(<span class="params">path, methods, middleware, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 路由命名</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="keyword">this</span>.opts.name || <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 路由对应的方法</span></span><br><span class="line">  <span class="keyword">this</span>.methods = [];</span><br><span class="line">  <span class="comment">// 路由参数名数组</span></span><br><span class="line">  <span class="keyword">this</span>.paramNames = [];</span><br><span class="line">  <span class="comment">// 路由处理中间件数组</span></span><br><span class="line">  <span class="keyword">this</span>.stack = <span class="built_in">Array</span>.isArray(middleware) ? middleware : [middleware];</span><br><span class="line">  <span class="comment">// 存储路由方法</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">this</span>.methods.push(method.toUpperCase());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.methods[l<span class="number">-1</span>] === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.methods.unshift(<span class="string">'HEAD'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将添加的回调处理中间件函数添加到 Layer 实例对象的 stack 数组中</span></span><br><span class="line">  <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = (<span class="keyword">typeof</span> fn);</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        methods.toString() + <span class="string">" `"</span> + (<span class="keyword">this</span>.opts.name || path) +<span class="string">"`: `middleware` "</span></span><br><span class="line">        + <span class="string">"must be a function, not `"</span> + type + <span class="string">"`"</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.path = path;</span><br><span class="line">  <span class="keyword">this</span>.regexp = pathToRegExp(path, <span class="keyword">this</span>.paramNames, <span class="keyword">this</span>.opts);</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">'defined route %s %s'</span>, <span class="keyword">this</span>.methods, <span class="keyword">this</span>.opts.prefix + <span class="keyword">this</span>.path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到, 对于 Layer 的实例对象, 核心的逻辑还是在于将 path 转化为正则表达式用于匹配请求的路由, 然后将路由的处理中间件添加到 Layer 的 stack 数组中. 注意这里的 stack 和 Router 里面的 stack 是不一样的, Router 的 stack 数组是存放每个路由对应的 Layer 实例对象的, 而 Layer 实例对象里面的 stack 数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数.</p>
<img src="http://weixinfactory.di1game.com/blog/router&layer.png">
<h2 id="method-相关函数"><a href="#method-相关函数" class="headerlink" title="method 相关函数"></a>method 相关函数</h2><p>所谓 method 就是 HTTP 协议中或者说是在 node 中支持的 HTTP 请求方法.其实我们可以通过打印 node 中的 HTTP 的方法来查看 node 支持的 HTTP method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'http'</span>).METHODS; <span class="comment">// ['ACL', ...., 'GET', 'POST', 'PUT', ...]</span></span><br></pre></td></tr></table></figure>
<p>在 koa-router 里面的体现就是我们可以通过在 router 实例对象上调用对应的方法函数来注册对应的 HTTP 方法的路由而且每个方法的核心逻辑都类似, 就是将传入的路由路径与对应的回调函数绑定, 所以我们可以遍历一个方法数组来快速构建原型的 method 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">methods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Router.prototype[method] = <span class="function"><span class="keyword">function</span> (<span class="params">name, path, middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> middleware;</span><br><span class="line">    <span class="comment">// 判断有没有传入 name 参数, 如果有则处理参数个数问题</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span> || path <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      path = name;</span><br><span class="line">      name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册路由</span></span><br><span class="line">    <span class="keyword">this</span>.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面函数中先判断 path 是否是字符串或者正则表达式是因为注册路由的时候还可以为路由进行命名(命名空间方便管理), 然后准确地获取回调的函数数组(注册路由可以接收多个回调), 这样如果匹配到某个路由, 回调函数数组中的函数就会依次执行. 留意到每个方法都会返回对象本身, 也就是说注册路由的时候是可以支持链式调用的.<br>此外, 我们可以看到, 每个方法的核心其实还是 register 函数, 所以我们下面看看 register 函数的逻辑.</p>
<h2 id="Router-prototype-register"><a href="#Router-prototype-register" class="headerlink" title="Router.prototype.register"></a>Router.prototype.register</h2><p>register 是注册路由的核心函数, 举个例子, 如果我们需要注册一个路径为 ‘/test’ 的接收 GET 方法的路由, 那么:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/test'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>其实它相当于下面这段代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(<span class="string">'/test'</span>, [<span class="string">'GET'</span>], [<span class="keyword">async</span> (ctx, next) =&gt; &#123;&#125;], &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到, 函数将路由作为第一个参数传入, 然后方法名放入到方法数组中作为第二个参数, 第三个函数是路由的回调数组, 其实每个路由注册的时候, 后面都可以添加很多个函数, 而这些函数都会被添加到一个数组里面, 如果被匹配到, 就会利用中间件机制来逐个执行这些函数. 最后一个函数是将路由的命名空间传入.<br>这里避免篇幅过长, 不再陈列 register 函数的代码, 请移步 koa-router 源码仓库关于 register 函数部分 查看.<br>register 函数的逻辑其实也很简单, 因为核心的代码全部都交由 Layer 类去完成了, register 函数只是负责处理 path 如果是数组的话那么需要递归调用 register 函数, 然后新建一个 Layer 类的实例对象, 并且检查在注册这个路由之间有没有注册过 param 路由参数校验函数, 如果有的话, 那么就使用 Layer.prototype.param 函数将校验函数加入到路由的中间件函数数组前面.</p>
<h2 id="Router-prototype-match"><a href="#Router-prototype-match" class="headerlink" title="Router.prototype.match"></a>Router.prototype.match</h2><p>通过上面的模块, 我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用 match 函数.先看一下 match 函数的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.match = <span class="function"><span class="keyword">function</span> (<span class="params">path, method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取所有路由 Layer 实例</span></span><br><span class="line">  <span class="keyword">var</span> layers = <span class="keyword">this</span>.stack;</span><br><span class="line">  <span class="keyword">var</span> layer;</span><br><span class="line">  <span class="comment">// 匹配结果</span></span><br><span class="line">  <span class="keyword">var</span> matched = &#123;</span><br><span class="line">    path: [],</span><br><span class="line">    pathAndMethod: [],</span><br><span class="line">    route: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 遍历路由 Router 的 stack 逐个判断</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> len = layers.length, i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    layer = layers[i];</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">'test %s %s'</span>, layer.path, layer.regexp);</span><br><span class="line">    <span class="comment">// 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则</span></span><br><span class="line">    <span class="keyword">if</span> (layer.match(path)) &#123;</span><br><span class="line">      <span class="comment">// 将对应的 Layer 实例加入到结果集的 path 数组中</span></span><br><span class="line">      matched.path.push(layer);</span><br><span class="line">      <span class="comment">// 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法</span></span><br><span class="line">      <span class="keyword">if</span> (layer.methods.length === <span class="number">0</span> || ~layer.methods.indexOf(method)) &#123;</span><br><span class="line">        <span class="comment">// 将 layer 放入到结果集的 pathAndMethod 中</span></span><br><span class="line">        matched.pathAndMethod.push(layer);</span><br><span class="line">        <span class="comment">// 这里是用于判断是否有真正匹配到路由处理函数</span></span><br><span class="line">        <span class="comment">// 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空</span></span><br><span class="line">        <span class="keyword">if</span> (layer.methods.length) matched.route = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> matched;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在 path 数组或者 pathAndMethod 数组中找到对应的 Layer 实例对象.</p>
<h2 id="Router-prototype-routes-middlewares"><a href="#Router-prototype-routes-middlewares" class="headerlink" title="Router.prototype.routes(middlewares)"></a>Router.prototype.routes(middlewares)</h2><p>如果根据一开始的 demo 例子, 在上面注册好了路由之后, 我们就可以使用 router.routes 来将路由模块添加到 koa 的中间件处理机制当中了. 由于 koa 的中间件插件是以一个函数的形式存在的, 所以 routes 函数返回值就是一个函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch.router = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到返回的 dispatch 函数在 routes 内部形成了一个闭包, 并且按照 koa 的中间件形式编写函数.对于 dispatch 函数内部逻辑就如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    debug(<span class="string">'%s %s'</span>, ctx.method, ctx.path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line">    <span class="comment">// 根据 path 值取的匹配的路由 Layer 实例对象</span></span><br><span class="line">    <span class="keyword">var</span> matched = router.match(path, ctx.method);</span><br><span class="line">    <span class="keyword">var</span> layerChain, layer, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ctx.router = router;</span><br><span class="line">    <span class="comment">// 如果没有匹配到对应的路由模块, 那么就直接跳过下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!matched.route) <span class="keyword">return</span> next();</span><br><span class="line">    <span class="comment">// 取路径与方法都匹配了的 Layer 实例对象</span></span><br><span class="line">    <span class="keyword">var</span> matchedLayers = matched.pathAndMethod</span><br><span class="line">    <span class="keyword">var</span> mostSpecificLayer = matchedLayers[matchedLayers.length - <span class="number">1</span>]</span><br><span class="line">    ctx._matchedRoute = mostSpecificLayer.path;</span><br><span class="line">    <span class="keyword">if</span> (mostSpecificLayer.name) &#123;</span><br><span class="line">      ctx._matchedRouteName = mostSpecificLayer.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建路径对应路由的处理中间件函数数组</span></span><br><span class="line">    <span class="comment">// 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理</span></span><br><span class="line">    <span class="comment">// 对应路由的 captures, params, 以及路由命名的函数</span></span><br><span class="line">    layerChain = matchedLayers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, layer</span>) </span>&#123;</span><br><span class="line">      memo.push(<span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// captures 是存储路由中参数的值的数组</span></span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line">        <span class="comment">// params 是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从 captures 中拿</span></span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line">        ctx.routerName = layer.name;</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="comment">// 使用 compose 模块将对应路由的处理中间件数组中的函数逐个执行</span></span><br><span class="line">    <span class="comment">// 当路由的处理函数中间件函数全部执行完, 再调用上一层级的 next 函数进入下一个中间件</span></span><br><span class="line">    <span class="keyword">return</span> compose(layerChain)(ctx, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Router-prototype-allowedMethod"><a href="#Router-prototype-allowedMethod" class="headerlink" title="Router.prototype.allowedMethod"></a>Router.prototype.allowedMethod</h2><p>对于 allowedMethod 方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行.同样地, 它也是以一个 koa 的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> implemented = <span class="keyword">this</span>.methods;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">allowedMethods</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码很简单, 就是保存 Router 配置中允许的 HTTP 方法数组在闭包内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">allowedMethods</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从这里可以看出, allowedMethods 函数是用于在中间件机制中处理返回结果的函数</span></span><br><span class="line">    <span class="comment">// 先执行 next 函数, next 函数返回的是一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> next().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allowed = &#123;&#125;;</span><br><span class="line">      <span class="comment">// allowedMethods 函数的逻辑建立在 statusCode 没有设置或者值为 404 的时候</span></span><br><span class="line">      <span class="keyword">if</span> (!ctx.status || ctx.status === <span class="number">404</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的 matched 就是在 match 函数执行之后返回结果集中的 path 数组</span></span><br><span class="line">        <span class="comment">// 也就是说请求路径与路由正则匹配的 layer 实例对象数组</span></span><br><span class="line">        ctx.matched.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">route</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 将这些 layer 路由的 HTTP 方法存储起来</span></span><br><span class="line">          route.methods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">            allowed[method] = method;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将上面的 allowed 整理为数组</span></span><br><span class="line">        <span class="keyword">var</span> allowedArr = <span class="built_in">Object</span>.keys(allowed);</span><br><span class="line">        <span class="comment">// implemented 就是 Router 配置中的 methods 数组, 也就是允许的方法</span></span><br><span class="line">        <span class="comment">// 这里通过 ~ 运算判断当前的请求方法是否在配置允许的方法中</span></span><br><span class="line">        <span class="comment">// 如果该方法不被允许</span></span><br><span class="line">        <span class="keyword">if</span> (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          <span class="comment">// 如果 Router 配置中配置 throw 为 true</span></span><br><span class="line">          <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">            <span class="keyword">var</span> notImplementedThrowable;</span><br><span class="line">            <span class="comment">// 如果配置中规定了 throw 抛出错误的函数, 那么就执行对应的函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> options.notImplemented === <span class="string">'function'</span>) &#123;</span><br><span class="line">              notImplementedThrowable = options.notImplemented(); <span class="comment">// set whatever the user returns from their function</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有则直接抛出 HTTP Error</span></span><br><span class="line">              notImplementedThrowable = <span class="keyword">new</span> HttpError.NotImplemented();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> notImplementedThrowable;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Router 配置 throw 为 false</span></span><br><span class="line">            <span class="comment">// 设置状态码为 501</span></span><br><span class="line">            ctx.status = <span class="number">501</span>;</span><br><span class="line">            <span class="comment">// 并且设置 Allow 头部, 值为上面得到的允许的方法数组 allowedArr</span></span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr.join(<span class="string">', '</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedArr.length) &#123;</span><br><span class="line">          <span class="comment">// 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码 statusCode 或者 statusCode 为 404 呢?</span></span><br><span class="line">          <span class="comment">// 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理 OPTIONS 请求的</span></span><br><span class="line">          <span class="comment">// 发出这个请求一般常见就是非简单请求, 则会发出预检请求 OPTIONS</span></span><br><span class="line">          <span class="comment">// 例如 application/json 格式的 POST 请求</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods</span></span><br><span class="line">          <span class="keyword">if</span> (ctx.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">            ctx.status = <span class="number">200</span>;</span><br><span class="line">            ctx.body = <span class="string">''</span>;</span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr.join(<span class="string">', '</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowed[ctx.method]) &#123;</span><br><span class="line">          <span class="comment">// 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数</span></span><br><span class="line">            <span class="comment">// 类似上面的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">              <span class="keyword">var</span> notAllowedThrowable;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">typeof</span> options.methodNotAllowed === <span class="string">'function'</span>) &#123;</span><br><span class="line">                notAllowedThrowable = options.methodNotAllowed(); <span class="comment">// set whatever the user returns from their function</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notAllowedThrowable = <span class="keyword">new</span> HttpError.MethodNotAllowed();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">throw</span> notAllowedThrowable;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 这里的状态码为 405</span></span><br><span class="line">              ctx.status = <span class="number">405</span>;</span><br><span class="line">              ctx.set(<span class="string">'Allow'</span>, allowedArr.join(<span class="string">', '</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得注意的是, Router.methods 数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误 501, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的 POST 路由但是用 GET 方法来获取数据), 这是一个客户端错误 405.</p>
<h2 id="Router-prototype-use"><a href="#Router-prototype-use" class="headerlink" title="Router.prototype.use"></a>Router.prototype.use</h2><p>use 函数就是用于添加中间件的, 只不过不同于 koa 中的 use 函数, router 的 use 函数添加的中间件函数会在所有路由执行之前执行.此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.use = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 中间件函数数组</span></span><br><span class="line">  <span class="keyword">var</span> middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> path;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持同时为多个路由绑定中间件函数: router.use(['/use', '/admin'], auth());</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(middleware[<span class="number">0</span>]) &amp;&amp; <span class="keyword">typeof</span> middleware[<span class="number">0</span>][<span class="number">0</span>] === <span class="string">'string'</span>) &#123;</span><br><span class="line">    middleware[<span class="number">0</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      router.use.apply(router, [p].concat(middleware.slice(<span class="number">1</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 直接返回, 下面是非数组 path 的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果第一个参数有传值为字符串, 说明有传路径</span></span><br><span class="line">  <span class="keyword">var</span> hasPath = <span class="keyword">typeof</span> middleware[<span class="number">0</span>] === <span class="string">'string'</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasPath) &#123;</span><br><span class="line">    path = middleware.shift();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  middleware.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有 router 属性, 说明这个中间件函数是由 Router.prototype.routes 暴露出来的</span></span><br><span class="line">    <span class="comment">// 属于嵌套路由</span></span><br><span class="line">    <span class="keyword">if</span> (m.router) &#123;</span><br><span class="line">      <span class="comment">// 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上</span></span><br><span class="line">      m.router.stack.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">nestedLayer</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有 path, 那么为需要嵌套的路由加上路径前缀</span></span><br><span class="line">        <span class="keyword">if</span> (path) nestedLayer.setPrefix(path);</span><br><span class="line">        <span class="comment">// 如果本身的 router 有前缀配置, 也添加上</span></span><br><span class="line">        <span class="keyword">if</span> (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);</span><br><span class="line">        <span class="comment">// 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上</span></span><br><span class="line">        router.stack.push(nestedLayer);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 这里与 register 函数的逻辑类似, 注册的时候检查添加参数校验函数 params</span></span><br><span class="line">      <span class="keyword">if</span> (router.params) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(router.params).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">          m.router.param(key, router.params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有 router 属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理</span></span><br><span class="line">      <span class="comment">// 如果没有 path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理</span></span><br><span class="line">      router.register(path || <span class="string">'(.*)'</span>, [], m, &#123; <span class="attr">end</span>: <span class="literal">false</span>, <span class="attr">ignoreCaptures</span>: !hasPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过上面我们就清楚, 在 koa-router 里面, 它将所有的路由与所有路由都适用的中间件函数都看做 Layer, 通过 Layer 来处理, 然后将他们的回调函数存储在 Layer 实例本身的 stack 数组中, 然后全局的 router 实例对象的 stack 数组存放所有的 Layer 达到全局管理的目的.</p>
<h1 id="router-处理请求的流程"><a href="#router-处理请求的流程" class="headerlink" title="router 处理请求的流程"></a>router 处理请求的流程</h1><p>上面就是 koa-router 的核心 API, 下面我们通过一张图来总结一下, 看一下当一个请求来临, koa-router 是如何处理的:</p>
<img src="http://weixinfactory.di1game.com/blog/request-process.png">
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="为什么需要在-GET-请求放一个-HEAD-请求"><a href="#为什么需要在-GET-请求放一个-HEAD-请求" class="headerlink" title="为什么需要在 GET 请求放一个 HEAD 请求 ?"></a>为什么需要在 GET 请求放一个 HEAD 请求 ?</h2><p>我们可以看到在 Layer 的构建函数里面, 在对于 methods 的处理中, 会进行判断如果该请求为 GET 请求, 那么就需要在 GET 请求前面添加一个 HEAD 方法, 其原因在于 HEAD 方法与 GET 方法基本是一致的,所以 koa-router 在处理 GET 请求的时候顺带将 HEAD 请求一并处理, 因为两者的区别在于 HEAD 请求不响应数据体.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/解析-SMTP-协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/解析-SMTP-协议/" itemprop="url">解析 SMTP 协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T15:00:54+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/解析-SMTP-协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/解析-SMTP-协议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SMTP 是属于应用层协议, 是基于 TCP 协议用于收发邮件的.我们常常需要在业务中使用邮件, 但是并没有对 smtp 协议有足够的了解, 我们下面就来全面地了解一下. smtp 服务器一般会开启 25 端口提供服务, 当然如果 smtp 服务器使用了安全认证也就是 ssl/tls, 那么就会开放 465 或 587 端口开放服务, 例如 smtp.qq.com.</p>
<h1 id="SMTP-的工作流程"><a href="#SMTP-的工作流程" class="headerlink" title="SMTP 的工作流程"></a>SMTP 的工作流程</h1><p>相信很多人在使用邮件服务的时候, 特别是在 nodejs 编写中, 都会直接使用像 nodemailer 这样的库来直接编写逻辑, 但这里并不会使用这样的库, 本着学习协议的细节的意思, 我们从零开始编写一个 smtp 客户端,要求客户端可以进行身份验证与发送多格式的邮件.<br>我们在最开始的时候, 需要先使用 socket 来进行 tcp 连接操作, 并且需要注意, 每个信息的末尾都要使用 \r\n 来表示该行信息结束.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> Net.Socket();</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 监听 data 事件接收服务器信息</span></span><br><span class="line">socket.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    data.push(chunk);</span><br><span class="line">    size += chunk.length</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 拼接 buffer</span></span><br><span class="line">socket.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.concat(data, size);</span><br><span class="line">    <span class="keyword">let</span> message = iconv.decode(buf, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.connect(&#123; host, port &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="HELO-命令"><a href="#HELO-命令" class="headerlink" title="HELO 命令"></a>HELO 命令</h2><p>经过上面的连接操作之后, 我们会收到:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">220 welcome</span><br></pre></td></tr></table></figure>
<p>220 为连接成功状态码, 后面为欢迎信息, 接下来我们就需要向服务器发起一个 HELO 命令, 主要是用于标识客户端自己身份的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'HELO debugmail.io\r\n'</span>); // debugmail.io 为 smtp 服务器域名</span><br></pre></td></tr></table></figure>
<p>发送了 HELO 命令之后. 会收到 250 状态码, 250 状态码会在后面多次用到, 所以我们使用全局变量来存放一些命令运行后的状态, 比如已经认证了或已经发送了某些命令.</p>
<h2 id="AUTH-LOGIN-命令"><a href="#AUTH-LOGIN-命令" class="headerlink" title="AUTH LOGIN 命令"></a>AUTH LOGIN 命令</h2><p>AUTH LOGIN 命令是用于登录 smtp 服务器的, 在上面接收到 250 状态码之后, 如果没有进行过认证的话,那么我们就需要进行认证操作:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'AUTH LOGIN\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p>发送了 AUTH LOGIN 命令之后, 服务器会发送一个 334 的状态码, 334 的状态码后面跟着的信息是 base64 编码后的 Username: 和 Password:, 第一个是 Username:, 类似这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">334 UGFzc3dvcmQ6</span><br></pre></td></tr></table></figure>
<p>这个时候我们接收到 334 状态码与后面的信息之后, 需要先 base64 解码判断是需要输入帐号还是密码, 注意, 如果是需要发送帐号, 那么我们就发送帐号, 格式是 base64 格式化后的字符串:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(`<span class="variable">$&#123;new Buffer(username).toString('base64')&#125;</span>\r\n`);</span><br></pre></td></tr></table></figure>
<p>认证成功后, 即帐号密码都正确后, 那么服务器就会返回 235 状态码表示认证信息已经成功.</p>
<h2 id="MAIL-FROM-命令"><a href="#MAIL-FROM-命令" class="headerlink" title="MAIL FROM 命令"></a>MAIL FROM 命令</h2><p>上面的认证信息登录成功后, 我们需要发送 MAIL FROM 命令, 很简单, 就是字面意思理解, 告诉 smtp 服务器此邮件是从那么邮件地址发送, 主要目的是验证该邮箱地址被不被邮件服务器支持.后面只能接一个地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'MAIL FROM: &lt;shawncheung702@gmail.com&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>注意, 这里的尖括号最好加上, 因为有些 smtp 服务器并不能解析不加尖括号的邮箱地址, 如果不加尖括号有可能会报错</p>
<h2 id="RCPT-TO-命令"><a href="#RCPT-TO-命令" class="headerlink" title="RCPT TO 命令"></a>RCPT TO 命令</h2><p>上面 MAIL FROM 成功后, 我们需要发送 RCPT TO 命令, 很简单, 就是字面意思理解, 告诉 smtp 服务器此邮件的接收地址是哪些, 能不能被邮件服务器支持, 注意, 邮件可能会被群发, 所以 RCPT TO 命令后面可能会有多个邮箱地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'RCPT TO: &lt;shawncheung702@gmail.com&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>同理, 这里的每个邮箱地址最好加上尖括号.</p>
<h2 id="DATA-命令"><a href="#DATA-命令" class="headerlink" title="DATA 命令"></a>DATA 命令</h2><p>在我们发送真实邮件内容实体之前, 我们需要先发送一个 DATA 命令, 告诉服务器我们接下来需要发送邮件实体数据:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'DATA\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p>发送了 DATA 命令之后, 服务器接收到之后, 会返回一个状态码与信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">354 Enter mail, end with <span class="string">"."</span> on a line by itself</span><br></pre></td></tr></table></figure>
<p>然后我们接收到 354 状态码之后, 就可以进行实体内容的组装发送了, 注意这里邮件所有实体内容发送完毕之后需要发送一个 . 号来标记数据已全部发送完毕.<br>而这里的数据, 有几个注意的地方:</p>
<p>1,需要指定邮件的 Content-Type, 如果是有附件的, 那么值为 multipart/mixed, 如果没有那么就是 multipart/alternative;<br>2,需要指定一个 boundary 也就是分隔符, 用于分割邮件的各个部分内容, 在每个部分的前后加上.<br>3,from, to 信息是需要加上的, 也即是我们通过邮件客户端看到的邮件头部信息, subject 头部是邮件的标题信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.content);</span><br><span class="line">      <span class="keyword">const</span> mimeVersion = <span class="string">'1.0'</span>;</span><br><span class="line">      <span class="keyword">const</span> boundary = <span class="string">`========<span class="subst">$&#123;(<span class="built_in">Math</span>.random() * <span class="number">10000000000000</span>).toFixed()&#125;</span>==`</span>;</span><br><span class="line">      socket.write(<span class="string">`Content-Type:multipart/mixed;\n boundary="<span class="subst">$&#123;boundary&#125;</span>"<span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">      socket.write(<span class="string">`MIME-Version: <span class="subst">$&#123;mimeVersion&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'from'</span>: <span class="comment">// 发出地址</span></span><br><span class="line">            socket.write(<span class="string">`From:<span class="subst">$&#123;<span class="keyword">this</span>.content[key]&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'to'</span>: <span class="comment">// 发往地址</span></span><br><span class="line">            socket.write(<span class="string">`To:<span class="subst">$&#123;<span class="keyword">this</span>.content[key]&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'subject'</span>: <span class="comment">// 标题信息</span></span><br><span class="line">            socket.write(<span class="string">`Subject:<span class="subst">$&#123;<span class="keyword">this</span>.content[key]&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'text'</span>: 处理文本信息</span><br><span class="line">            socket.write(<span class="string">`\n--<span class="subst">$&#123;boundary&#125;</span>\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`Content-Type:text/plain; charset="utf-8"\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`MIME-Version:<span class="subst">$&#123;mimeVersion&#125;</span>\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`\n<span class="subst">$&#123;text&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'html'</span>: <span class="comment">// 处理 html</span></span><br><span class="line">            socket.write(<span class="string">`\n--<span class="subst">$&#123;boundary&#125;</span>\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`Content-Type:text/html; charset="utf-8"\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`MIME-Version:<span class="subst">$&#123;mimeVersion&#125;</span>\n`</span>);</span><br><span class="line">            socket.write(<span class="string">`\n<span class="subst">$&#123;html&#125;</span><span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'attachment'</span>: <span class="comment">// 处理附件</span></span><br><span class="line">            <span class="keyword">const</span> filePaths = attachment;</span><br><span class="line">            <span class="keyword">const</span> fileNum = attachment.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> path <span class="keyword">of</span> filePaths) &#123;</span><br><span class="line">              <span class="keyword">await</span> Mail.handleFile(&#123; path, boundary, mimeVersion &#125;, socket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 邮件结尾</span></span><br><span class="line">      socket.write(<span class="string">`\n--<span class="subst">$&#123;boundary&#125;</span>--\n<span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br><span class="line">      <span class="comment">// 根据 354 的信息, 需要 . 进行结尾</span></span><br><span class="line">      socket.write(<span class="string">`<span class="subst">$&#123;msgEnd&#125;</span>.<span class="subst">$&#123;msgEnd&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="QUIT-命令"><a href="#QUIT-命令" class="headerlink" title="QUIT 命令"></a>QUIT 命令</h2><p>在完成上面的步骤之后, 其实一封邮件的发送基本属于完成, 我们现在需要做的就是告诉 smtp 服务器我们的操作已经完成了, 正式结束所有操作, 所以我们需要发送一个结束命令, 也就是 QUIT:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.write(<span class="string">'QUIIT\r\n'</span>);</span><br></pre></td></tr></table></figure>
<p>发送了这个命令之后, 服务器收到该命令之后就会知道操作已经完成了, 那么就会返回一个状态码与信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">221 Bye</span><br></pre></td></tr></table></figure>
<p>状态码 221 就是结束状态码, Bye 是服务器的结束信息.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我下面贴出一个真实的 smtp 客户端与服务器的沟通过程:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">220 smtp.qq.com Esmtp QQ Mail Server</span><br><span class="line"></span><br><span class="line">250 smtp.qq.com // 欢迎信息</span><br><span class="line"></span><br><span class="line">334 VXNlcm5hbWU6  // 认证帐号</span><br><span class="line"></span><br><span class="line">334 UGFzc3dvcmQ6  // 认证密码</span><br><span class="line"></span><br><span class="line">235 Authentication successful  // 登录成功</span><br><span class="line"></span><br><span class="line">250 Ok // mail from 命令成功</span><br><span class="line"></span><br><span class="line">250 Ok // rcpt to 命令成功</span><br><span class="line"></span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; // data 命令</span><br><span class="line"></span><br><span class="line">250 Ok: queued as // 邮件发送等待中</span><br><span class="line"></span><br><span class="line">221 Bye // smtp 协议沟通结束</span><br></pre></td></tr></table></figure></p>
<h1 id="SMTP-的-MIME-格式"><a href="#SMTP-的-MIME-格式" class="headerlink" title="SMTP 的 MIME 格式"></a>SMTP 的 MIME 格式</h1><p>我们知道, 一封邮件不仅仅是只可以发送文本信息, 它还可以发送 html 信息与附件.先说对于 html 文档,我们需要在局部的地方写上不同的 Content-Type:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--==========boundary==</span><br><span class="line">Content-Type: text/html; charset=<span class="string">"utf-8"</span></span><br><span class="line">MIME-Version: 1.0</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">--==========boundary==</span><br></pre></td></tr></table></figure>
<p>而对于附件, 我们需要在局部写上 Content-Disposition 头部, 因为我们需要的是附件, 需要可以提供下载, 所以值为 attachment, 并且指定文件名:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--==========boundary==</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Disposition: attachment; filename=<span class="string">"test.md"</span></span><br><span class="line">MIME-Version: 1.0</span><br><span class="line"></span><br><span class="line">VXNlcm5hbWU6</span><br><span class="line">--==========boundary==</span><br></pre></td></tr></table></figure>
<p>注意这里我并没有根据文件名来决定 Content-Type, 而是统一使用 application/octet-stream, 使用流的方式传文件.文件的内容使用 base64 编码, 所以头部需要添加 Content-Transfer-Encoding 来说明编码格式.</p>
<h2 id="邮件中的附件"><a href="#邮件中的附件" class="headerlink" title="邮件中的附件"></a>邮件中的附件</h2><p>邮件中的图片有两种形式, 一种可以使用 img 标签放在邮件体中的 html 内容中, 另一个就是使用附件的形式发送.对于在 html 文档中的, 就是像平时的 img 标签中使用, 而对于附件来说, 我们就可以直接通过 stream 读文件, 然后进行 base64 编码, 将图片放到协议的头部信息里面, 实现附件功能.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/koa-源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/koa-源码解析/" itemprop="url">koa 源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T14:16:07+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/koa-源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/koa-源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>koa 框架是基于 Node.js 下一代的 web server 框架, 舍弃了回调写法, 提高了错误处理效率, 而且其不绑定任何中间件, 核心代码只提供优雅轻量的函数库.<br>平时经常使用到 koa 框架, 所以希望通过阅读源码学习其思想, 本文是基于 koa2 的源码进行分析.</p>
<h1 id="koa-整体架构"><a href="#koa-整体架构" class="headerlink" title="koa 整体架构"></a>koa 整体架构</h1><p>koa 框架的源码结构非常简单, 在 lib 文件夹下, 只有 4 个文件, 分别是 application.js, context.js, request.js, response.js.<br>而 application.js 是 koa 框架的入口文件, context.js 的作用是创建网络请求的上下文对象, request.js 是用于包装 koa 的 request 对象的, response.js<br>则是用于包装 koa 的 response 对象的. 我们这里使用 koa 框架建立一个简单的 node 服务, 以此来逐步了解 koa 内部机理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码, 先生成了一个 koa 对象, 然后通过使用 use 函数往 server 中添加中间件函数, 最后使用 listen 函数进行对 3000 端口的监听.</p>
<h1 id="koa-源码剖析"><a href="#koa-源码剖析" class="headerlink" title="koa 源码剖析"></a>koa 源码剖析</h1><p>由上面的简单代码, 我们会有几个疑问: koa 对象中包含了些什么属性与方法? use 函数对于中间件函数的处理是怎么样的? listen 函数做了什么?<br>因此我们先来看一下 application.js 的源码:</p>
<h2 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h2><p>application.js 暴露了一个 Application 类供我们使用, 也即是说, 我们 new 一个 koa 对象实质上就是新建一个 Application 的实例对象. 而 Application 类是继承<br>于 EventEmitter (Node.js events 模块)的, 所以我们在 koa 实例对象上可以使用 on, emit 等方法进行事件监听.</p>
<h3 id="生成-application-对象"><a href="#生成-application-对象" class="headerlink" title="生成 application 对象"></a>生成 application 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 因为继承于 EventEmitter, 这里需要调用 super</span></span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.middleware = [];</span><br><span class="line">        <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">        <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">        <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">        <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">        <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">        <span class="keyword">this</span>[util.inspect.custom] = <span class="keyword">this</span>.inspect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 constructor 函数中, 实例对象会初始化几个重要的属性, proxy 属性是代理设置, middleware 属性是中间件数组, 用于存储中间件函数的, subdomainOffset 属性是子域名偏移量<br>设置, env 属性保存 node 的环境变量 NODE_ENV 值, context, requets, response 则是 koa 自身的包装的 context 对象, request 对象, response 对象. 这里特别讲解一下 proxy 属性与<br>subdomainOffset 属性. proxy 属性值是 true 或者 false, 它的作用在于是否获取真正的客户端 ip 地址(详细请看附录的第一点). subdomainOffset 属性会改变获取 subdomain 时返回数组的值,<br>比如 test.page.example.com 域名, 如果设置 subdomainOffset 为 2, 那么返回的数组值为 [“page”, “test”], 如果设置为 3, 那么返回数组值为 [“test”].</p>
<h3 id="use-与中间件"><a href="#use-与中间件" class="headerlink" title="use 与中间件"></a>use 与中间件</h3><p>use 函数内部仅仅是对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise), 如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.<br>所以, 所谓中间件函数的串联其实就是通过数组来逐个执行的, 至于 koa 是怎么利用 koa-compose 建立起核心的中间件机制的, 这里按下不表, 详细请阅读本人的 理解 koa 中间件机制 博文.</p>
<h3 id="listen-原理"><a href="#listen-原理" class="headerlink" title="listen 原理"></a>listen 原理</h3><p>listen 函数的原理其实很简单, 它实际上是一个缩写的函数, 它本质上就是在内部通过 Node 原生的 http 模块建立起一个 http server, 而这个 http server 的回调函数使用的是 koa 中的 callback 函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">  debug(<span class="string">'listen'</span>);</span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">  <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就来讲解一下核心的 callback 函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);  <span class="comment">// 使用 compose 建立中间件机制</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);  <span class="comment">// 如果没有对 error 事件进行监听, 那么绑定 error 事件监听处理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// handleRequest 函数相当于 http.creatServer 的回调函数, 有 req, res 两个参数, 代表原生的 request, response 对象.</span></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res); <span class="comment">// 每次接受一个新的请求就是生成一次全新的 context</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  res.statusCode = <span class="number">404</span>;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err); <span class="comment">// 错误处理</span></span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx); <span class="comment">// 响应处理</span></span><br><span class="line">  onFinished(res, onerror); <span class="comment">// 为 res 对象添加错误处理响应, 当 res 响应结束时, 执行 context 中的 onerror 函数(这里需要注意区分 context 与 koa 实例中的 onerror)</span></span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror); <span class="comment">// 执行中间件数组所有函数, 并结束时调用 respond 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 this.createContext 函数, 它的用于就是生成一个新的 context 对象并建立 koa 中 context, requets, response 属性之间与原生 http 对象的关系的.而 handleRequest 函数只是负责执行<br>中间件所有的函数, 并在中间件函数执行结束的时候调用 respond.<br>对于在 koa 中的 context 对象, request 对象, response 对象与 http 模块原生的 req 与 res 之间的关系我并不打算陈列代码, 下面我以图解的形式来帮助阅读:</p>
<img src="http://weixinfactory.di1game.com/blog/applicaton.png">
<h3 id="对请求的响应处理-respond"><a href="#对请求的响应处理-respond" class="headerlink" title="对请求的响应处理 respond"></a>对请求的响应处理 respond</h3><p>对于 respond 函数, 其核心就是根据不同类型的数据对 http 的响应头部与响应体 body 做对应的处理.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// allow bypassing koa</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> === ctx.respond) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  <span class="comment">// writable 是原生的 response 对象的 writeable 属性, 检查是否是可写流</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.writable) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">const</span> code = ctx.status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore body</span></span><br><span class="line">  <span class="comment">// 如果响应的 statusCode 是属于 body 为空的类型, 例如 204, 205, 304, 将 body 置为 null</span></span><br><span class="line">  <span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">    <span class="comment">// strip headers</span></span><br><span class="line">    ctx.body = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 HEAD 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'HEAD'</span> == ctx.method) &#123;</span><br><span class="line">    <span class="comment">// headersSent 属性 Node 原生的 response 对象上的, 用于检查 http 响应头部是否已经被发送</span></span><br><span class="line">    <span class="comment">// 如果头部未被发送, 那么添加 length 头部</span></span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status body</span></span><br><span class="line">  <span class="comment">// 如果 body 值为空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == body) &#123;</span><br><span class="line">    <span class="comment">// body 值为 context 中的 message 属性或 code</span></span><br><span class="line">    body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">    <span class="comment">// 修改头部的 type 与 length 属性</span></span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = <span class="string">'text'</span>;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// responses</span></span><br><span class="line">  <span class="comment">// 对 body 为 buffer 类型的进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="comment">// 对 body 为字符串类型的进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="comment">// 对 body 为流形式的进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json</span></span><br><span class="line">  <span class="comment">// 对 body 为 json 格式的数据进行处理, 1: 将 body 转化为 json 字符串, 2: 添加 length 头部信息</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 respond 函数中, 主要是运用 node http 模块中的响应对象中的 end 方法与 koa context 对象中代理的属性进行最终响应对象的设置.</p>
<h2 id="request-js"><a href="#request-js" class="headerlink" title="request.js"></a>request.js</h2><p>主要是对原生的 http 模块的 requets 对象进行封装, 其实就是对 request 对象某些属性或方法通过重写 getter/setter 函数进行代理, 请看下面的图进行更好的理解:</p>
<img src="http://weixinfactory.di1game.com/blog/request.png">
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>我们可以看到 request 中有很多 accept 相关的方法, 我们来看看 accept 相关的内容协商的知识:<br>所谓内容协商, 就是客户端向服务端请求文件, 返回符合某些标准的文件, 而除了服务端将所有版本的文件全部返回由<br>客户端来决定使用哪个版本这种比较浪费网络资源的方法之外, 我们还可以使用通过请求/响应头部进行交流并返回合适版本的方法.</p>
<table>
<thead>
<tr>
<th>请求头字段</th>
<th>解释</th>
<th>对应响应头 </th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>告诉服务端可以接收的类型(text/html, application/json 等)</td>
<td>Content-Type </td>
</tr>
<tr>
<td>Accept-charset</td>
<td>告诉服务端可以接收的字符集类型(utf8, GBK 等)</td>
<td>Content-Type  </td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告诉服务端可以接收的压缩类型(gzip, deflate 等)</td>
<td>Content-Encoding  </td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告诉服务端可以接受的语言类型(zh-CN, en 等)</td>
<td>Content-Language  </td>
</tr>
</tbody>
</table>
<p>   使用上面的头部字段就可以达到请求合适的文档类型.而对于客户端与服务端之间可能有多个实体, 比如 CDN, 缓存服务<br>器等等, 万一中间实体缓存了错误的文件版本, 那么后果就是客户端有可能无法正确地解析该文件.所以需要 vary 响应<br>头部字段, vary 字段的值类似于这样: vary: user-agent, location. vary 字段是告诉中间实体如何正确判断有效的<br>缓存文件版本, 比如像上面的值, 那就是利用请求的 user-agent, location 两个头部的字段生成的 hash, 如果再有请<br>求过来并且请求的 ua 与 location 头部字段生成的 hash 有缓存, 那么就返回对应的缓存文件.</p>
<h2 id="response-js"><a href="#response-js" class="headerlink" title="response.js"></a>response.js</h2><p>同样的, response 也是对 http 模块的 response 对象进行封装, 通过对 response 对象的某些属性或方法通过重写 getter/setter 函数进行代理, 请看下面的图帮助理解:<br><img src="http://weixinfactory.di1game.com/blog/koaresponse.png"></p>
<h3 id="Content-disposition"><a href="#Content-disposition" class="headerlink" title="Content-disposition"></a>Content-disposition</h3><p>在 response 对象的 attachment 方法中, 我们可以看到对 HTTP 头部的 Content-disposition 字段进行了处理, 那么究竟 Content-disposition 字段是做什么用的?<br>Content-disposition 是用于说明这个返回的信息是以什么形式展示的, 例如如果值为 inline, 那么就是以网页的一部分或者整个页面展示, 如果是 attachment 的话, 就是以下载附件的<br>形式展示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: inline; <span class="comment">// 网页一部分或者整个网页展示</span></span><br><span class="line">Content-Disposition: attachment; <span class="comment">// 下载网页附件的形式</span></span><br><span class="line">Content-Disposition: attachment, filename=<span class="string">"xxx.ext"</span>; <span class="comment">// 还可以使用 filename 来指定文件名</span></span><br></pre></td></tr></table></figure>
<p>当然, 在 Content-Type 为 multipart/form-data 格式中, Content-Disposition 也会发挥作用, 用于定义表单的键名:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form; boundry=<span class="string">"boundry"</span></span><br><span class="line"></span><br><span class="line">--boundry</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"field1"</span></span><br><span class="line"></span><br><span class="line">value</span><br><span class="line">--boundry</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"field2"</span></span><br><span class="line"></span><br><span class="line">value</span><br></pre></td></tr></table></figure>
<h3 id="缓存协商"><a href="#缓存协商" class="headerlink" title="缓存协商"></a>缓存协商</h3><p>在 request 中使用 fresh 字段来判断这个请求需要的内容是否是最新的, 其原理也就是我们熟知的 http 缓存机制, 内部通过 fresh 这个库, 判断请求头部中的 if-modify-since 与<br>if-match-since 对比于响应头部中的 last-Modified 字段与 ETag 字段.当然, 在检查这两个字段之前, 还需要检查一下请求头部的 Cache-Control 头部, 如果 Cache-Control 头部<br>是 no-cache, 那么就代表请求信息必须是最新的, 如果不是 no-cache, 接着就需要判断上面说的两个字段.而 last-modified 与 ETag 的检查有没有优先顺序呢? 答案是有的.<br>koa 中先检查 ETag 有没有过期, 手段是通过检查 if-match-since 字段与 Etag 字段是否相同, 然后会检查 last-modified 有没有过期, 手段是通过检查 if-modify-since 与 last-modified<br>的日期是不是 last-modified 日期时间戳小于 if-modified-since 日期时间戳, 如果是那么说明内容是新鲜的, 如果不是说明内容是旧的.</p>
<h2 id="context-js"><a href="#context-js" class="headerlink" title="context.js"></a>context.js</h2><p>分析了上面的 request 与 response, context 的分析更为简单了, context 的核心就是通过 delegates 这一个库, 将 request, response 对象上的属性方法代理到 context 对象上.<br>也就是说例如 this.ctx.headersSent 相当于 this.response.headersSent. request 对象与 response 对象的所有方法与属性都能在 ctx 对象上找到. 这里我们来看一下 delegates 库<br>的属性代理函数的片段, 借此理解一下 context 是如何代理 request 与 response 上的属性与方法的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delegate(proto, <span class="string">'response'</span>)</span><br><span class="line">  .getter(<span class="string">'headerSent'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Delegator.prototype.getter = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// this.proto 指向原型, 这里的 proto 就是上面的 proto, 也就是说 context 对象</span></span><br><span class="line">  <span class="keyword">var</span> proto = <span class="keyword">this</span>.proto;</span><br><span class="line">  <span class="comment">// target 是指 'response' 字符串</span></span><br><span class="line">  <span class="keyword">var</span> target = <span class="keyword">this</span>.target;</span><br><span class="line">  <span class="comment">// 将 name 加入到 delegator 实例对象的getters数组中</span></span><br><span class="line">  <span class="keyword">this</span>.getters.push(name);</span><br><span class="line">  <span class="comment">// 调用原生的 __defineGetter__ 方法进行getter代理,那么 proto[name] 就相当于 proto[target][name]</span></span><br><span class="line">  <span class="comment">// 而 context.response 就相当于 response 对象</span></span><br><span class="line">  <span class="comment">// 由此实现属性代理</span></span><br><span class="line">  proto.__defineGetter__(name, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[target][name];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在 koa 中, 错误处理分为在 application.js 中的 onerror 处理函数与在 context.js 中的 onerror 处理函数.这两者绑定的位置是不一样的, context 的 onerror 函数是绑定在<br>中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的, 这里的意图显而易见, 就是为了处理请求或响应中出现的 error 事件的.<br>而 application.js 中的 onerror 函数是绑定在 koa 实例对象上的, 它监听的是整个对象的 error 事件.</p>
<h2 id="context-中的错误处理"><a href="#context-中的错误处理" class="headerlink" title="context 中的错误处理"></a>context 中的错误处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">onerror(err) &#123;</span><br><span class="line">  <span class="comment">// don't do anything if there is no error.</span></span><br><span class="line">  <span class="comment">// this allows you to pass `this.onerror`</span></span><br><span class="line">  <span class="comment">// to node-style callbacks.</span></span><br><span class="line">  <span class="comment">// 没有错误则忽略, 不执行下面的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 将错误转化为 Error 实例</span></span><br><span class="line">  <span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> <span class="built_in">Error</span>)) err = <span class="keyword">new</span> <span class="built_in">Error</span>(util.format(<span class="string">'non-error thrown: %j'</span>, err));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> headerSent = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.headerSent || !<span class="keyword">this</span>.writable) &#123;</span><br><span class="line">    headerSent = err.headerSent = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate</span></span><br><span class="line">  <span class="comment">// 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行</span></span><br><span class="line">  <span class="keyword">this</span>.app.emit(<span class="string">'error'</span>, err, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nothing we can do here other</span></span><br><span class="line">  <span class="comment">// than delegate to the app-level</span></span><br><span class="line">  <span class="comment">// handler and log.</span></span><br><span class="line">  <span class="comment">// 如果响应头部已经发送(或者 socket 不可写), 那么退出函数</span></span><br><span class="line">  <span class="keyword">if</span> (headerSent) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 http 原生 res 对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; res &#125; = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// first unset all headers</span></span><br><span class="line">  <span class="comment">// 根据文档 res.getHeaderNames 函数是 7.7.0 版本后添加的, 这里为了兼容做了一个判断</span></span><br><span class="line">  <span class="comment">// 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> res.getHeaderNames === <span class="string">'function'</span>) &#123;</span><br><span class="line">    res.getHeaderNames().forEach(<span class="function"><span class="params">name</span> =&gt;</span> res.removeHeader(name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res._headers = &#123;&#125;; <span class="comment">// Node &lt; 7.7</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then set those specified</span></span><br><span class="line">  <span class="keyword">this</span>.set(err.headers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// force text/plain</span></span><br><span class="line">  <span class="comment">// 出错后响应类型为 text/plain</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ENOENT support</span></span><br><span class="line">  <span class="comment">// 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'ENOENT'</span> == err.code) err.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default to 500</span></span><br><span class="line">  <span class="comment">// 默认设置状态码为 500</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'number'</span> != <span class="keyword">typeof</span> err.status || !statuses[err.status]) err.status = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// respond</span></span><br><span class="line">  <span class="keyword">const</span> code = statuses[err.status];</span><br><span class="line">  <span class="keyword">const</span> msg = err.expose ? err.message : code;</span><br><span class="line">  <span class="comment">// 设置响应状态码</span></span><br><span class="line">  <span class="keyword">this</span>.status = err.status;</span><br><span class="line">  <span class="comment">// 设置响应 body 长度</span></span><br><span class="line">  <span class="keyword">this</span>.length = Buffer.byteLength(msg);</span><br><span class="line">  <span class="comment">// 返回 message</span></span><br><span class="line">  <span class="keyword">this</span>.res.end(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="application-中的错误处理"><a href="#application-中的错误处理" class="headerlink" title="application 中的错误处理"></a>application 中的错误处理</h2><p>application 中的错误处理是对 koa 实例对象中例如函数执行出错等等内部错误进行处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onerror(err) &#123;</span><br><span class="line">  <span class="comment">// 判断 err 是否是 Error 实例</span></span><br><span class="line">  assert(err <span class="keyword">instanceof</span> <span class="built_in">Error</span>, <span class="string">`non-error thrown: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 忽略 404 错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">404</span> == err.status || err.expose) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 如果有静默设置, 则忽略</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.silent) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 打印出出错堆栈</span></span><br><span class="line">  <span class="keyword">const</span> msg = err.stack || err.toString();</span><br><span class="line">  <span class="built_in">console</span>.error();</span><br><span class="line">  <span class="built_in">console</span>.error(msg.replace(<span class="regexp">/^/gm</span>, <span class="string">'  '</span>));</span><br><span class="line">  <span class="built_in">console</span>.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主要作用就是处理出错函数的堆栈打印, 方便我们进行问题定位.</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="1-koa-中-proxy-属性真正用途是什么"><a href="#1-koa-中-proxy-属性真正用途是什么" class="headerlink" title="1. koa 中 proxy 属性真正用途是什么?"></a>1. koa 中 proxy 属性真正用途是什么?</h2><p>要知道, 我们在实际运用中, 可能会使用很多的代理服务器, 包括我们常见的正向代理与反向代理, 虽然代理的用处很大, 但是无法避免地我们有时需要知晓真正的客户端的请求 ip,<br>而其实实际上, 服务器并不知道真正的客户端请求 ip, 即使你使用 socket.remoteAddrss 属性来查看, 因为这个请求是代理服务器转发给服务器的, 幸好代理服务器例如 nginx 提供了一个<br>HTTP 头部来记录每次代理服务器的源 IP 地址, 也就是 X-Forwarded-For 头部.形式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 192.168.210.13, 210.112.40.13, 43.56.210.10</span><br></pre></td></tr></table></figure>
<p>如果一个请求跳转了很多代理服务器, 那么 X-Forwarded-For 头部的 ip 地址就会越多, 第一个就是原始的客户端请求 ip, 第二个就是第一个代理服务器 ip, 以此类推.<br>当然, X-Forwarded-For 并不完全可信, 因为中间的代理服务器可能会”使坏”更改某些 IP. 而 koa 中 proxy 属性的设置就是如果使用 true, 那么就是使用 X-Forwarded-For 头部的第一个<br>ip 地址, 如果使用 false, 则使用 server 中的 socket.remoteAddress 属性值.<br>除了 X-Forwarded-For 之外, proxy 还会影响 X-Forwarded-proto 的使用, 和 X-Forwarded-For 一样, X-Forwarded-proto 记录最开始的请求连接使用的协议类型(HTTP/HTTPS), 因为客户端与<br>服务端之间可能会存在很多层代理服务器, 而代理服务器与服务端之间可能只是使用 HTTP 协议, 并没有使用 HTTPS, 所以 proxy 属性为 true 的话, koa 的 protocol 属性会去取 X-Forwarded-proto 头部的值(koa 中 protocol 属性会先使用 tlsSocket.encrypted 属性来判断是否是 https 协议, 如果是则直接返回 ‘https’).</p>
<h2 id="2-javascript-中的-运算符"><a href="#2-javascript-中的-运算符" class="headerlink" title="2. javascript 中的 ~ 运算符"></a>2. javascript 中的 ~ 运算符</h2><p>~ 运算符是一元运算符, 它的运算逻辑是如下: 例如计算 ~1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 将十进制的 1 转化为二进制的 0001</span><br><span class="line">2. 先对 0001 按位取反: 1110</span><br><span class="line">3. 然后我们知道最高位为 1, 所以数字为负数, 然后将除去最高位剩下的三位数字再按位取反得到 001</span><br><span class="line">4. 然后再向 001 加 1 即 001 + 001 得到 010, 转为十进制为数字 2</span><br><span class="line">5. 再加上我们之前最高位为 1, 所以最后数字为负数即 -2</span><br><span class="line">6. 所以 ~1 === -2</span><br></pre></td></tr></table></figure>
<p>用简略的表达式来说明就是 ~ X = -(X + 1).而我们可以看到在 koa 中, length 返回的结果使用了 ~~length 这样的形式, 两次二进制否运算, 这样的目的是为了值得安全输出, 如果 ~ 运算符后面的值<br>是 NaN, null, 空字符串, 空数组, 非数字字符串的话, 返回值为 -1, 而对于小数, ~ 运算符会向下取整.其实对于小数, ~ 运算会选择忽略小数部分, 对于非整数的值会先执行 Number 类型转化.<br>所以两次二进制否运算 ~~, 可以使小数向下取整, 让非整数值输出为 0(~-1 === 0).</p>
<h2 id="3-Buffer-byteLength-计算长度"><a href="#3-Buffer-byteLength-计算长度" class="headerlink" title="3. Buffer.byteLength 计算长度"></a>3. Buffer.byteLength 计算长度</h2><p>细心阅读源码会发现, 在 koa 中设置响应的 length 头部信息, 并不是使用字符串的 length 属性来设置的, 而是通过 Buffer.byteLength 方法来计算得到的. 为什么要这么做呢?<br>HTTP Content-length 头部的数值其实是字节数而不是字符数, 对于汉字来说, utf-8 编码模式下一个汉字字符需要 3 个字节, 所以不能使用字符串的 length 属性来赋值 Content-Length 头部.</p>
<h2 id="4-Restful-中的幂等性"><a href="#4-Restful-中的幂等性" class="headerlink" title="4. Restful 中的幂等性"></a>4. Restful 中的幂等性</h2><p>我们可以在 request 对象中找到, 有 idempotent 属性, 它用于判断请求方法 verb 是不是幂等的. 所谓幂等性, 就是无论这个相同的请求请求多少次, 得到的数据结果是一样的. 而在 HTTP 的方法中,<br>GET, HEAD, PUT, DELETE, TRACK, OPTIONS 请求都是幂等的. 对于 POST 与 PATCH 方法则是不幂等的.<br>这里特别讲解一下 PUT 的含义, PUT 的定义是 Replace(create or update), 如果存在那么就替换, 如果不存在那么就新增数据.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/理解-koa-的中间件机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/理解-koa-的中间件机制/" itemprop="url">理解 koa 的中间件机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T11:40:28+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/理解-koa-的中间件机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/理解-koa-的中间件机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件 在 Node.js 中被广泛使用,它泛指一种特定的设计模式、一系列的处理单元、过滤器和处理程序,以函数的形式存在,连接在一起,形成一个异步队列,来完成对任何数据的预处理和后处理.</p>
<p>它的优点在于 灵活性:使用中间件我们用极少的操作就能得到一个插件,用最简单的方法就能将新的过滤器和处理程序扩展到现有的系统上.</p>
<h2 id="常规中间件模式"><a href="#常规中间件模式" class="headerlink" title="常规中间件模式"></a>常规中间件模式</h2><p>中间件模式中,最基础的组成部分就是 中间件管理器,我们可以用它来组织和执行中间件的函数,如图所示:<br><img src="http://weixinfactory.di1game.com/blog/middleware.png"></p>
<h1 id="面向切面编程-AOP"><a href="#面向切面编程-AOP" class="headerlink" title="面向切面编程(AOP)"></a>面向切面编程(AOP)</h1><p>AOP(面向切面的编程)主要是将一些与核心业务逻辑模块无关的功能抽离出来,这些功能通常包括日志统计,安全控制,或者是异常处理等等.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'核心函数,内部逻辑'</span>); </span><br><span class="line">&#125;</span><br><span class="line">myFunc();  <span class="comment">// 核心函数,内部逻辑</span></span><br></pre></td></tr></table></figure>
<p>before函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原函数执行前执行 fn 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prorotype.before = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// [Function: myFunc]</span></span><br><span class="line">    <span class="built_in">console</span>.log(fn) <span class="comment">// [Function]</span></span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>; <span class="comment">//用来保存调用这个函数的引用,如myFunc调用此函数,则_this指向myFunc</span></span><br><span class="line">    <span class="comment">//返回一个函数,相当于一个代理函数,也就是说,这里包含了原函数和新函数,原函数指的是myFunc,新函数指的是fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">//修正this的指向,将this指针指向fn,将myFunc接收的参数传给fn处理.</span></span><br><span class="line">        <span class="keyword">return</span> _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">//执行原函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行myFunc函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myFunc = myFunc.before(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'预处理'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myFunc(); <span class="comment">//先输出预处理,再输出核心函数,内部逻辑</span></span><br></pre></td></tr></table></figure></p>
<p>after函数同理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原函数执行后执行 fn 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r = _this.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">//先执行原函数,也就是myFunc</span></span><br><span class="line">        fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);   <span class="comment">//再执行新函数</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myFunc = myFunc.before(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'预处理'</span>);  </span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'后处理'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myFunc(); <span class="comment">//先输出预处理,再输出核心函数,内部逻辑,最后输出后处理</span></span><br></pre></td></tr></table></figure>
<p>上面这两个函数是通过在 Function.prototype 上添加两个函数: before, after.<br>两个函数的返回值都是一个函数, 这个函数会按照次序执行函数.<br>这样函数各自保持了他们的整洁性.但是这样的 before 与 after 函数的简单使用缺陷也是很明显的,<br>他们并不支持异步的函数, 而日常开发中异步的场景有非常多, 所以这样的代码还是只能在 demo 中使用,不适合生产环境中使用.所以我们来看一下 koa 框架是怎么做的.</p>
<h1 id="koa-中的中间件"><a href="#koa-中的中间件" class="headerlink" title="koa 中的中间件"></a>koa 中的中间件</h1><p>koa 是 nodejs 中非常精简的框架, 其中的精粹思想就是洋葱模型(中间件模型), 它实现的核心就是借助 compose 这个库来实现的.这里我主要看的是 koa2 所使用的 compose 源码,<br>对于 koa1 的 compose 源码其实思想是一致的, 只不过它针对的是 generator 函数, koa2 针对的是 async 函数, 相比之下 async 会更符合潮流.<br>对于 compose 也就是 koa 的核心思想就是像下面这个图:<br><img src="http://weixinfactory.di1game.com/blog/koa-core.png"></p>
<h2 id="那么-compose-是怎么实现上面这个思想的呢"><a href="#那么-compose-是怎么实现上面这个思想的呢" class="headerlink" title="那么 compose 是怎么实现上面这个思想的呢?"></a>那么 compose 是怎么实现上面这个思想的呢?</h2><p>下面我们来解读一下 compose 的源码, compose 的源码非常精简!</p>
<h3 id="middleware-in-koa1"><a href="#middleware-in-koa1" class="headerlink" title="middleware in koa1"></a>middleware in koa1</h3><p>对于 koa1 来说, 它是基于 generator 函数与 co 类库的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 解释一下传入的 next, 这个传入的 next 函数是在所有中间件执行后的"最后"一个函数, 这里的"最后"并不是真正的最后,</span></span><br><span class="line">    <span class="comment">// 而是像上面那个图中的圆心, 执行完圆心之后, 会返回去执行上一个中间件函数(middleware[length - 1])剩下的逻辑</span></span><br><span class="line">    <span class="comment">// 简称圆心函数</span></span><br><span class="line">    <span class="comment">// 如果没有传入那就就赋值为一个空函数</span></span><br><span class="line">    <span class="keyword">if</span> (!next) next = noop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = middleware.length;</span><br><span class="line">    <span class="comment">// 从后往前加载中间件</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="comment">// 将后面一个函数传给前面的函数作为 next 函数, 前面函数中的 next 参数其实就是下一个中间件函数</span></span><br><span class="line">      next = middleware[i].call(<span class="keyword">this</span>, next);</span><br><span class="line">      <span class="comment">// 这里可以知道 next 函数都是 generator 函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'isGenerator:'</span>, (<span class="keyword">typeof</span> next.next === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> next.throw === <span class="string">'function'</span>)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 yield 委托执行生成器函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> *next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">noop</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下 koa1 中的 compose 为什么从后往前遍历中间件函数而且还使用了 call 函数执行了一次, 这个是因为 koa1 中默认函数都是生成器函数, 我们知道生成器函数<br>执行一次并不是真正地执行了函数内部的逻辑, 而是初始化得到一个生成器对象, 而在生成器对象生成的时候, 我们需要对函数需要的 next 函数进行传值, 所以会采用逆序遍历.</p>
<h3 id="middleware-in-koa2"><a href="#middleware-in-koa2" class="headerlink" title="middleware in koa2"></a>middleware in koa2</h3><p>对于 koa2 来说中间件机制 compose 基于 async 与 Promise: 会稍微比 koa1 中的复杂一点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传入的 middleware 参数必须是数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="comment">// middleware 数组的元素必须是函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数闭包, 保持对 middleware 的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 context 参数是作为一个全局的设置, 所有中间件的第一个参数就是传入的 context, 这样可以</span></span><br><span class="line">    <span class="comment">// 在 context 中对某个值或者某些值做"洋葱处理"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释一下传入的 next, 这个传入的 next 函数是在所有中间件执行后的"最后"一个函数, 这里的"最后"并不是真正的最后,</span></span><br><span class="line">    <span class="comment">// 而是像上面那个图中的圆心, 执行完圆心之后, 会返回去执行上一个中间件函数(middleware[length - 1])剩下的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 是用来记录中间件函数运行到了哪一个函数</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 执行第一个中间件函数</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// i 是洋葱模型的记录已经运行的函数中间件的下标, 如果一个中间件里面运行两次 next, 那么 i 是会比 index 小的.</span></span><br><span class="line">      <span class="comment">// 如果对这个地方不清楚可以查看下面的图</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) &#123;</span><br><span class="line">        <span class="comment">// 这里的 next 就是一开始 compose 传入的 next, 意味着当中间件函数数列执行完后, 执行这个 next 函数, 即圆心</span></span><br><span class="line">        fn = next</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有函数, 直接返回空值的 Promise</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 为什么这里要包一层 Promise? </span></span><br><span class="line">        <span class="comment">// 因为 async 需要后面是 Promise, 然后 next 函数返回值就是 dispatch 函数的返回值, </span></span><br><span class="line">        <span class="comment">// 所以运行 async next(); 需要 next 包一层 Promise,next 函数是固定的, 可以执行下一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的核心:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123; <span class="comment">// [Promise, Promise, Promise]</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123; <span class="comment">// next</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next <span class="comment">// 当运行结束的时候,next赋值给fn,next是undefined</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve() <span class="comment">// !undefined,跳出当前的中间件,执行逻辑函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">          fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)) <span class="comment">// 此处相当于将上一个函数执行结果的Promise对象传入下一个函数</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于在一个中间件函数中两次调用 next 函数导致出错, 我这里提供一个简单的例子供大家参考:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">  <span class="comment">// async 与 co + yield 的模型不同, await 是需要后面是 promise 的函数, 并且自己执行一次, 而 co 是自己拿到 value 然后帮你自动执行.</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">await</span> next(); <span class="comment">// 两次调用 next</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleware = [first, second, third];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> com = compose(middleware);</span><br><span class="line"></span><br><span class="line">com(<span class="string">'ctx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hey'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果第一个中间件中没有两次调用 next 函数, 那么正确的结果为 1 2 3 ‘hey’ 4 ‘ctx’. 对于出错的真正原因是如下图:<br><img src="http://weixinfactory.di1game.com/blog/next-err.png"></p>
<p>在第 5 步中, 传入的 i 值为 1, 因为还是在第一个中间件函数内部, 但是 compose 内部的 index 已经是 3 了, 所以 i &lt; 3, 所以报错了, 可知在一个中间件函数内部不允许多次调用 next 函数.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/http请求返回gzip处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="胡剑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuJian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/http请求返回gzip处理/" itemprop="url">http请求返回gzip处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T11:33:49+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/21/http请求返回gzip处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/21/http请求返回gzip处理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>引入模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const http = require(<span class="string">'http'</span>);</span><br><span class="line">const qs = require(<span class="string">'querystring'</span>)</span><br><span class="line">const zlib = require(<span class="string">'zlib'</span>); ==&gt; 压缩解压数据</span><br></pre></td></tr></table></figure></p>
<p>程序主题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'www.kuaidi100.com'</span>,</span><br><span class="line">    path: <span class="string">'/query?type=yuantong&amp;postid=804233238482357128&amp;temp=0.04453568682858622&amp;phone=123'</span>,</span><br><span class="line">    methos: <span class="string">'GET'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>, <span class="comment">//这里设置返回的编码方式 设置其他的会是乱码</span></span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">        <span class="string">'Vary'</span>: <span class="string">'Accept-Encoding'</span>,</span><br><span class="line">        <span class="string">'Transfer-Encoding'</span>: <span class="string">'chunked'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.get(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> + res.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(res.headers[<span class="string">'content-encoding'</span>])</span><br><span class="line">    <span class="keyword">var</span> html = [];</span><br><span class="line">    res.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        html.push(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> buffer = Buffer.concat(html);</span><br><span class="line">        <span class="comment">// 对返回的数据buffer进行解压操作</span></span><br><span class="line">        zlib.gunzip(buffer, <span class="function"><span class="keyword">function</span>(<span class="params">err, decoded</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(decoded.toString());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"获取失败"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars2.githubusercontent.com/u/46552129?s=460&v=4" alt="胡剑">
            
              <p class="site-author-name" itemprop="name">胡剑</p>
              <p class="site-description motion-element" itemprop="description">时间就是一个小偷,它让你猝不及防地失去,那些你很容易忽略掉的东西,当你记起时，却怎么也找不着了...</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/FassbenderMichael" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/540907171/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/df1f61cabea9" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/179974868/" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>豆瓣</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡剑</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fassbendermichael.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
